{
  "version": 3,
  "sources": ["../../node_modules/isomorphic-ws/browser.js", "../../node_modules/@automerge/automerge-repo-network-websocket/dist/BrowserWebSocketClientAdapter.js", "../../node_modules/@automerge/automerge-repo-network-websocket/dist/messages.js", "../../node_modules/@automerge/automerge-repo-network-websocket/dist/protocolVersion.js", "../../node_modules/@automerge/automerge-repo-network-websocket/dist/assert.js", "../../node_modules/@automerge/automerge-repo-network-websocket/dist/toArrayBuffer.js", "../../node_modules/@automerge/automerge-repo-network-websocket/dist/NodeWSServerAdapter.js"],
  "sourcesContent": ["// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nexport default ws\n", "import { NetworkAdapter, cbor, } from \"@automerge/automerge-repo/slim\";\nimport WebSocket from \"isomorphic-ws\";\nimport debug from \"debug\";\nimport { isErrorMessage, isPeerMessage, } from \"./messages.js\";\nimport { ProtocolV1 } from \"./protocolVersion.js\";\nimport { assert } from \"./assert.js\";\nimport { toArrayBuffer } from \"./toArrayBuffer.js\";\nclass WebSocketNetworkAdapter extends NetworkAdapter {\n    socket;\n}\nexport class BrowserWebSocketClientAdapter extends WebSocketNetworkAdapter {\n    url;\n    retryInterval;\n    #isReady = false;\n    #retryIntervalId;\n    #log = debug(\"automerge-repo:websocket:browser\");\n    remotePeerId; // this adapter only connects to one remote client at a time\n    constructor(url, retryInterval = 5000) {\n        super();\n        this.url = url;\n        this.retryInterval = retryInterval;\n        this.#log = this.#log.extend(url);\n    }\n    connect(peerId, peerMetadata) {\n        if (!this.socket || !this.peerId) {\n            // first time connecting\n            this.#log(\"connecting\");\n            this.peerId = peerId;\n            this.peerMetadata = peerMetadata ?? {};\n        }\n        else {\n            this.#log(\"reconnecting\");\n            assert(peerId === this.peerId);\n            // Remove the old event listeners before creating a new connection.\n            this.socket.removeEventListener(\"open\", this.onOpen);\n            this.socket.removeEventListener(\"close\", this.onClose);\n            this.socket.removeEventListener(\"message\", this.onMessage);\n            this.socket.removeEventListener(\"error\", this.onError);\n        }\n        // Wire up retries\n        if (!this.#retryIntervalId)\n            this.#retryIntervalId = setInterval(() => {\n                this.connect(peerId, peerMetadata);\n            }, this.retryInterval);\n        this.socket = new WebSocket(this.url);\n        this.socket.binaryType = \"arraybuffer\";\n        this.socket.addEventListener(\"open\", this.onOpen);\n        this.socket.addEventListener(\"close\", this.onClose);\n        this.socket.addEventListener(\"message\", this.onMessage);\n        this.socket.addEventListener(\"error\", this.onError);\n        // Mark this adapter as ready if we haven't received an ack in 1 second.\n        // We might hear back from the other end at some point but we shouldn't\n        // hold up marking things as unavailable for any longer\n        setTimeout(() => this.#ready(), 1000);\n        this.join();\n    }\n    onOpen = () => {\n        this.#log(\"open\");\n        clearInterval(this.#retryIntervalId);\n        this.#retryIntervalId = undefined;\n        this.join();\n    };\n    // When a socket closes, or disconnects, remove it from the array.\n    onClose = () => {\n        this.#log(\"close\");\n        if (this.remotePeerId)\n            this.emit(\"peer-disconnected\", { peerId: this.remotePeerId });\n        if (this.retryInterval > 0 && !this.#retryIntervalId)\n            // try to reconnect\n            setTimeout(() => {\n                assert(this.peerId);\n                return this.connect(this.peerId, this.peerMetadata);\n            }, this.retryInterval);\n    };\n    onMessage = (event) => {\n        this.receiveMessage(event.data);\n    };\n    /** The websocket error handler signature is different on node and the browser.  */\n    onError = (event // node\n    ) => {\n        if (\"error\" in event) {\n            // (node)\n            if (event.error.code !== \"ECONNREFUSED\") {\n                /* c8 ignore next */\n                throw event.error;\n            }\n        }\n        else {\n            // (browser) We get no information about errors. https://stackoverflow.com/a/31003057/239663\n            // There will be an error logged in the console (`WebSocket connection to 'wss://foo.com/'\n            // failed`), but by design the error is unavailable to scripts. We'll just assume this is a\n            // failed connection.\n        }\n        this.#log(\"Connection failed, retrying...\");\n    };\n    #ready() {\n        if (this.#isReady)\n            return;\n        this.#isReady = true;\n        this.emit(\"ready\", { network: this });\n    }\n    join() {\n        assert(this.peerId);\n        assert(this.socket);\n        if (this.socket.readyState === WebSocket.OPEN) {\n            this.send(joinMessage(this.peerId, this.peerMetadata));\n        }\n        else {\n            // We'll try again in the `onOpen` handler\n        }\n    }\n    disconnect() {\n        assert(this.peerId);\n        assert(this.socket);\n        this.send({ type: \"leave\", senderId: this.peerId });\n    }\n    send(message) {\n        if (\"data\" in message && message.data?.byteLength === 0)\n            throw new Error(\"Tried to send a zero-length message\");\n        assert(this.peerId);\n        assert(this.socket);\n        if (this.socket.readyState !== WebSocket.OPEN)\n            throw new Error(`Websocket not ready (${this.socket.readyState})`);\n        const encoded = cbor.encode(message);\n        this.socket.send(toArrayBuffer(encoded));\n    }\n    peerCandidate(remotePeerId, peerMetadata) {\n        assert(this.socket);\n        this.#ready();\n        this.remotePeerId = remotePeerId;\n        this.emit(\"peer-candidate\", {\n            peerId: remotePeerId,\n            peerMetadata,\n        });\n    }\n    receiveMessage(messageBytes) {\n        const message = cbor.decode(new Uint8Array(messageBytes));\n        assert(this.socket);\n        if (messageBytes.byteLength === 0)\n            throw new Error(\"received a zero-length message\");\n        if (isPeerMessage(message)) {\n            const { peerMetadata } = message;\n            this.#log(`peer: ${message.senderId}`);\n            this.peerCandidate(message.senderId, peerMetadata);\n        }\n        else if (isErrorMessage(message)) {\n            this.#log(`error: ${message.message}`);\n        }\n        else {\n            this.emit(\"message\", message);\n        }\n    }\n}\nfunction joinMessage(senderId, peerMetadata) {\n    return {\n        type: \"join\",\n        senderId,\n        peerMetadata,\n        supportedProtocolVersions: [ProtocolV1],\n    };\n}\n", "// TYPE GUARDS\nexport const isJoinMessage = (message) => message.type === \"join\";\nexport const isLeaveMessage = (message) => message.type === \"leave\";\nexport const isPeerMessage = (message) => message.type === \"peer\";\nexport const isErrorMessage = (message) => message.type === \"error\";\n", "export const ProtocolV1 = \"1\";\n", "/* c8 ignore start */\nexport function assert(value, message = \"Assertion failed\") {\n    if (value === false || value === null || value === undefined) {\n        const error = new Error(trimLines(message));\n        error.stack = removeLine(error.stack, \"assert.ts\");\n        throw error;\n    }\n}\nconst trimLines = (s) => s\n    .split(\"\\n\")\n    .map(s => s.trim())\n    .join(\"\\n\");\nconst removeLine = (s = \"\", targetText) => s\n    .split(\"\\n\")\n    .filter(line => !line.includes(targetText))\n    .join(\"\\n\");\n/* c8 ignore end */\n", "/**\n * This incantation deals with websocket sending the whole underlying buffer even if we just have a\n * uint8array view on it\n */\nexport const toArrayBuffer = (bytes) => {\n    const { buffer, byteOffset, byteLength } = bytes;\n    return buffer.slice(byteOffset, byteOffset + byteLength);\n};\n", "import WebSocket from \"isomorphic-ws\";\nimport debug from \"debug\";\nconst log = debug(\"WebsocketServer\");\nimport { cbor as cborHelpers, NetworkAdapter, } from \"@automerge/automerge-repo/slim\";\nimport { isJoinMessage, isLeaveMessage, } from \"./messages.js\";\nimport { ProtocolV1 } from \"./protocolVersion.js\";\nimport { assert } from \"./assert.js\";\nimport { toArrayBuffer } from \"./toArrayBuffer.js\";\nconst { encode, decode } = cborHelpers;\nexport class NodeWSServerAdapter extends NetworkAdapter {\n    server;\n    keepAliveInterval;\n    sockets = {};\n    constructor(server, keepAliveInterval = 5000) {\n        super();\n        this.server = server;\n        this.keepAliveInterval = keepAliveInterval;\n    }\n    connect(peerId, peerMetadata) {\n        this.peerId = peerId;\n        this.peerMetadata = peerMetadata;\n        this.server.on(\"close\", () => {\n            clearInterval(keepAliveId);\n            this.disconnect();\n        });\n        this.server.on(\"connection\", (socket) => {\n            // When a socket closes, or disconnects, remove it from our list\n            socket.on(\"close\", () => {\n                this.#removeSocket(socket);\n            });\n            socket.on(\"message\", message => this.receiveMessage(message, socket));\n            // Start out \"alive\", and every time we get a pong, reset that state.\n            socket.isAlive = true;\n            socket.on(\"pong\", () => (socket.isAlive = true));\n            this.emit(\"ready\", { network: this });\n        });\n        const keepAliveId = setInterval(() => {\n            // Terminate connections to lost clients\n            const clients = this.server.clients;\n            clients.forEach(socket => {\n                if (socket.isAlive) {\n                    // Mark all clients as potentially dead until we hear from them\n                    socket.isAlive = false;\n                    socket.ping();\n                }\n                else {\n                    this.#terminate(socket);\n                }\n            });\n        }, this.keepAliveInterval);\n    }\n    disconnect() {\n        const clients = this.server.clients;\n        clients.forEach(socket => {\n            this.#terminate(socket);\n            this.#removeSocket(socket);\n        });\n    }\n    send(message) {\n        assert(\"targetId\" in message && message.targetId !== undefined);\n        if (\"data\" in message && message.data?.byteLength === 0)\n            throw new Error(\"Tried to send a zero-length message\");\n        const senderId = this.peerId;\n        assert(senderId, \"No peerId set for the websocket server network adapter.\");\n        const socket = this.sockets[message.targetId];\n        if (!socket) {\n            log(`Tried to send to disconnected peer: ${message.targetId}`);\n            return;\n        }\n        const encoded = encode(message);\n        const arrayBuf = toArrayBuffer(encoded);\n        socket.send(arrayBuf);\n    }\n    receiveMessage(messageBytes, socket) {\n        const message = decode(messageBytes);\n        const { type, senderId } = message;\n        const myPeerId = this.peerId;\n        assert(myPeerId);\n        const documentId = \"documentId\" in message ? \"@\" + message.documentId : \"\";\n        const { byteLength } = messageBytes;\n        log(`[${senderId}->${myPeerId}${documentId}] ${type} | ${byteLength} bytes`);\n        if (isJoinMessage(message)) {\n            const { peerMetadata, supportedProtocolVersions } = message;\n            const existingSocket = this.sockets[senderId];\n            if (existingSocket) {\n                if (existingSocket.readyState === WebSocket.OPEN) {\n                    existingSocket.close();\n                }\n                this.emit(\"peer-disconnected\", { peerId: senderId });\n            }\n            // Let the repo know that we have a new connection.\n            this.emit(\"peer-candidate\", { peerId: senderId, peerMetadata });\n            this.sockets[senderId] = socket;\n            const selectedProtocolVersion = selectProtocol(supportedProtocolVersions);\n            if (selectedProtocolVersion === null) {\n                this.send({\n                    type: \"error\",\n                    senderId: this.peerId,\n                    message: \"unsupported protocol version\",\n                    targetId: senderId,\n                });\n                this.sockets[senderId].close();\n                delete this.sockets[senderId];\n            }\n            else {\n                this.send({\n                    type: \"peer\",\n                    senderId: this.peerId,\n                    peerMetadata: this.peerMetadata,\n                    selectedProtocolVersion: ProtocolV1,\n                    targetId: senderId,\n                });\n            }\n        }\n        else if (isLeaveMessage(message)) {\n            const { senderId } = message;\n            const socket = this.sockets[senderId];\n            /* c8 ignore next */\n            if (!socket)\n                return;\n            this.#terminate(socket);\n        }\n        else {\n            this.emit(\"message\", message);\n        }\n    }\n    #terminate(socket) {\n        this.#removeSocket(socket);\n        socket.terminate();\n    }\n    #removeSocket(socket) {\n        const peerId = this.#peerIdBySocket(socket);\n        if (!peerId)\n            return;\n        this.emit(\"peer-disconnected\", { peerId });\n        delete this.sockets[peerId];\n    }\n    #peerIdBySocket = (socket) => {\n        const isThisSocket = (peerId) => this.sockets[peerId] === socket;\n        const result = Object.keys(this.sockets).find(isThisSocket);\n        return result ?? null;\n    };\n}\nconst selectProtocol = (versions) => {\n    if (versions === undefined)\n        return ProtocolV1;\n    if (versions.includes(ProtocolV1))\n        return ProtocolV1;\n    return null;\n};\n"],
  "mappings": "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",
  "names": ["s", "debug", "import_debug", "debug", "senderId", "socket"]
}
