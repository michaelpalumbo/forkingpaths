{
  "version": 3,
  "sources": ["../../node_modules/@automerge/automerge/dist/mjs/constants.js", "../../node_modules/@automerge/automerge/dist/mjs/text.js", "../../node_modules/@automerge/automerge/dist/mjs/counter.js", "../../node_modules/@automerge/automerge/dist/mjs/numbers.js", "../../node_modules/@automerge/automerge/dist/mjs/raw_string.js", "../../node_modules/uuid/dist/esm-browser/rng.js", "../../node_modules/uuid/dist/esm-browser/regex.js", "../../node_modules/uuid/dist/esm-browser/validate.js", "../../node_modules/uuid/dist/esm-browser/stringify.js", "../../node_modules/uuid/dist/esm-browser/parse.js", "../../node_modules/uuid/dist/esm-browser/v35.js", "../../node_modules/uuid/dist/esm-browser/md5.js", "../../node_modules/uuid/dist/esm-browser/v3.js", "../../node_modules/uuid/dist/esm-browser/native.js", "../../node_modules/uuid/dist/esm-browser/v4.js", "../../node_modules/uuid/dist/esm-browser/sha1.js", "../../node_modules/uuid/dist/esm-browser/v5.js", "../../node_modules/@automerge/automerge/dist/mjs/uuid.js", "../../node_modules/@automerge/automerge/dist/mjs/wasm_bindgen_output/web/automerge_wasm.js", "../../node_modules/@automerge/automerge/dist/mjs/low_level.js", "../../node_modules/@automerge/automerge/dist/mjs/proxies.js", "../../node_modules/@automerge/automerge/dist/mjs/internal_state.js", "../../node_modules/@automerge/automerge/dist/mjs/conflicts.js", "../../node_modules/@automerge/automerge/dist/mjs/stable.js", "../../node_modules/@automerge/automerge/dist/mjs/next_slim.js"],
  "sourcesContent": ["// Properties of the document root object\nexport const STATE = Symbol.for(\"_am_meta\"); // symbol used to hide application metadata on automerge objects\nexport const TRACE = Symbol.for(\"_am_trace\"); // used for debugging\nexport const OBJECT_ID = Symbol.for(\"_am_objectId\"); // symbol used to hide the object id on automerge objects\nexport const IS_PROXY = Symbol.for(\"_am_isProxy\"); // symbol used to test if the document is a proxy object\nexport const CLEAR_CACHE = Symbol.for(\"_am_clearCache\"); // symbol used to tell a proxy object to clear its cache\nexport const UINT = Symbol.for(\"_am_uint\");\nexport const INT = Symbol.for(\"_am_int\");\nexport const F64 = Symbol.for(\"_am_f64\");\nexport const COUNTER = Symbol.for(\"_am_counter\");\nexport const TEXT = Symbol.for(\"_am_text\");\n", "import { TEXT, STATE } from \"./constants.js\";\nexport class Text {\n    constructor(text) {\n        if (typeof text === \"string\") {\n            this.elems = [...text];\n        }\n        else if (Array.isArray(text)) {\n            this.elems = text;\n        }\n        else if (text === undefined) {\n            this.elems = [];\n        }\n        else {\n            throw new TypeError(`Unsupported initial value for Text: ${text}`);\n        }\n        Reflect.defineProperty(this, TEXT, { value: true });\n    }\n    get length() {\n        return this.elems.length;\n    }\n    //eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get(index) {\n        return this.elems[index];\n    }\n    /**\n     * Iterates over the text elements character by character, including any\n     * inline objects.\n     */\n    [Symbol.iterator]() {\n        const elems = this.elems;\n        let index = -1;\n        return {\n            next() {\n                index += 1;\n                if (index < elems.length) {\n                    return { done: false, value: elems[index] };\n                }\n                else {\n                    return { done: true };\n                }\n            },\n        };\n    }\n    /**\n     * Returns the content of the Text object as a simple string, ignoring any\n     * non-character elements.\n     */\n    toString() {\n        if (!this.str) {\n            // Concatting to a string is faster than creating an array and then\n            // .join()ing for small (<100KB) arrays.\n            // https://jsperf.com/join-vs-loop-w-type-test\n            this.str = \"\";\n            for (const elem of this.elems) {\n                if (typeof elem === \"string\")\n                    this.str += elem;\n                else\n                    this.str += \"\\uFFFC\";\n            }\n        }\n        return this.str;\n    }\n    /**\n     * Returns the content of the Text object as a sequence of strings,\n     * interleaved with non-character elements.\n     *\n     * For example, the value `['a', 'b', {x: 3}, 'c', 'd']` has spans:\n     * `=> ['ab', {x: 3}, 'cd']`\n     */\n    toSpans() {\n        if (!this.spans) {\n            this.spans = [];\n            let chars = \"\";\n            for (const elem of this.elems) {\n                if (typeof elem === \"string\") {\n                    chars += elem;\n                }\n                else {\n                    if (chars.length > 0) {\n                        this.spans.push(chars);\n                        chars = \"\";\n                    }\n                    this.spans.push(elem);\n                }\n            }\n            if (chars.length > 0) {\n                this.spans.push(chars);\n            }\n        }\n        return this.spans;\n    }\n    /**\n     * Returns the content of the Text object as a simple string, so that the\n     * JSON serialization of an Automerge document represents text nicely.\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Updates the list item at position `index` to a new value `value`.\n     */\n    set(index, value) {\n        if (this[STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        this.elems[index] = value;\n    }\n    /**\n     * Inserts new list items `values` starting at position `index`.\n     */\n    insertAt(index, ...values) {\n        if (this[STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        if (values.every(v => typeof v === \"string\")) {\n            this.elems.splice(index, 0, ...values.join(\"\"));\n        }\n        else {\n            this.elems.splice(index, 0, ...values);\n        }\n    }\n    /**\n     * Deletes `numDelete` list items starting at position `index`.\n     * if `numDelete` is not given, one item is deleted.\n     */\n    deleteAt(index, numDelete = 1) {\n        if (this[STATE]) {\n            throw new RangeError(\"object cannot be modified outside of a change block\");\n        }\n        this.elems.splice(index, numDelete);\n    }\n    map(callback) {\n        this.elems.map(callback);\n    }\n    lastIndexOf(searchElement, fromIndex) {\n        this.elems.lastIndexOf(searchElement, fromIndex);\n    }\n    concat(other) {\n        return new Text(this.elems.concat(other.elems));\n    }\n    every(test) {\n        return this.elems.every(test);\n    }\n    filter(test) {\n        return new Text(this.elems.filter(test));\n    }\n    find(test) {\n        return this.elems.find(test);\n    }\n    findIndex(test) {\n        return this.elems.findIndex(test);\n    }\n    forEach(f) {\n        this.elems.forEach(f);\n    }\n    includes(elem) {\n        return this.elems.includes(elem);\n    }\n    indexOf(elem) {\n        return this.elems.indexOf(elem);\n    }\n    join(sep) {\n        return this.elems.join(sep);\n    }\n    reduce(f) {\n        this.elems.reduce(f);\n    }\n    reduceRight(f) {\n        this.elems.reduceRight(f);\n    }\n    slice(start, end) {\n        return new Text(this.elems.slice(start, end));\n    }\n    some(test) {\n        return this.elems.some(test);\n    }\n    toLocaleString() {\n        this.toString();\n    }\n}\n", "import { COUNTER } from \"./constants.js\";\n/**\n * The most basic CRDT: an integer value that can be changed only by\n * incrementing and decrementing. Since addition of integers is commutative,\n * the value trivially converges.\n */\nexport class Counter {\n    constructor(value) {\n        this.value = value || 0;\n        Reflect.defineProperty(this, COUNTER, { value: true });\n    }\n    /**\n     * A peculiar JavaScript language feature from its early days: if the object\n     * `x` has a `valueOf()` method that returns a number, you can use numerical\n     * operators on the object `x` directly, such as `x + 1` or `x < 4`.\n     * This method is also called when coercing a value to a string by\n     * concatenating it with another string, as in `x + ''`.\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\n     */\n    valueOf() {\n        return this.value;\n    }\n    /**\n     * Returns the counter value as a decimal string. If `x` is a counter object,\n     * this method is called e.g. when you do `['value: ', x].join('')` or when\n     * you use string interpolation: `value: ${x}`.\n     */\n    toString() {\n        return this.valueOf().toString();\n    }\n    /**\n     * Returns the counter value, so that a JSON serialization of an Automerge\n     * document represents the counter simply as an integer.\n     */\n    toJSON() {\n        return this.value;\n    }\n    /**\n     * Increases the value of the counter by `delta`. If `delta` is not given,\n     * increases the value of the counter by 1.\n     *\n     * Will throw an error if used outside of a change callback.\n     */\n    increment(_delta) {\n        throw new Error(\"Counters should not be incremented outside of a change callback\");\n    }\n    /**\n     * Decreases the value of the counter by `delta`. If `delta` is not given,\n     * decreases the value of the counter by 1.\n     *\n     * Will throw an error if used outside of a change callback.\n     */\n    decrement(_delta) {\n        throw new Error(\"Counters should not be decremented outside of a change callback\");\n    }\n}\n/**\n * An instance of this class is used when a counter is accessed within a change\n * callback.\n */\nclass WriteableCounter extends Counter {\n    constructor(value, context, path, objectId, key) {\n        super(value);\n        this.context = context;\n        this.path = path;\n        this.objectId = objectId;\n        this.key = key;\n    }\n    /**\n     * Increases the value of the counter by `delta`. If `delta` is not given,\n     * increases the value of the counter by 1.\n     */\n    increment(delta) {\n        delta = typeof delta === \"number\" ? delta : 1;\n        this.context.increment(this.objectId, this.key, delta);\n        this.value += delta;\n        return this.value;\n    }\n    /**\n     * Decreases the value of the counter by `delta`. If `delta` is not given,\n     * decreases the value of the counter by 1.\n     */\n    decrement(delta) {\n        return this.increment(typeof delta === \"number\" ? -delta : -1);\n    }\n}\n/**\n * Returns an instance of `WriteableCounter` for use in a change callback.\n * `context` is the proxy context that keeps track of the mutations.\n * `objectId` is the ID of the object containing the counter, and `key` is\n * the property name (key in map, or index in list) where the counter is\n * located.\n */\nexport function getWriteableCounter(value, context, path, objectId, key) {\n    return new WriteableCounter(value, context, path, objectId, key);\n}\n//module.exports = { Counter, getWriteableCounter }\n", "// Convenience classes to allow users to strictly specify the number type they want\nimport { INT, UINT, F64 } from \"./constants.js\";\nexport class Int {\n    constructor(value) {\n        if (!(Number.isInteger(value) &&\n            value <= Number.MAX_SAFE_INTEGER &&\n            value >= Number.MIN_SAFE_INTEGER)) {\n            throw new RangeError(`Value ${value} cannot be a uint`);\n        }\n        this.value = value;\n        Reflect.defineProperty(this, INT, { value: true });\n        Object.freeze(this);\n    }\n}\nexport class Uint {\n    constructor(value) {\n        if (!(Number.isInteger(value) &&\n            value <= Number.MAX_SAFE_INTEGER &&\n            value >= 0)) {\n            throw new RangeError(`Value ${value} cannot be a uint`);\n        }\n        this.value = value;\n        Reflect.defineProperty(this, UINT, { value: true });\n        Object.freeze(this);\n    }\n}\nexport class Float64 {\n    constructor(value) {\n        if (typeof value !== \"number\") {\n            throw new RangeError(`Value ${value} cannot be a float64`);\n        }\n        this.value = value || 0.0;\n        Reflect.defineProperty(this, F64, { value: true });\n        Object.freeze(this);\n    }\n}\n", "export class RawString {\n    constructor(val) {\n        this.val = val;\n    }\n    /**\n     * Returns the content of the RawString object as a simple string\n     */\n    toString() {\n        return this.val;\n    }\n    toJSON() {\n        return this.val;\n    }\n}\n", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;", "import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import validate from './validate.js';\n\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nexport default parse;", "import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return unsafeStringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}", "/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\nexport default md5;", "import v35 from './v35.js';\nimport md5 from './md5.js';\nconst v3 = v35('v3', 0x30, md5);\nexport default v3;", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\nexport default sha1;", "import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;", "import { v4 } from \"uuid\";\nfunction defaultFactory() {\n    return v4().replace(/-/g, \"\");\n}\nlet factory = defaultFactory;\nexport const uuid = () => {\n    return factory();\n};\nuuid.setFactory = newFactory => {\n    factory = newFactory;\n};\nuuid.reset = () => {\n    factory = defaultFactory;\n};\n", "let wasm;\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* @param {any} options\n* @returns {Automerge}\n*/\nexport function create(options) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.create(retptr, addHeapObject(options));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return Automerge.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} data\n* @param {any} options\n* @returns {Automerge}\n*/\nexport function load(data, options) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.load(retptr, addHeapObject(data), addHeapObject(options));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return Automerge.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {any} change\n* @returns {Uint8Array}\n*/\nexport function encodeChange(change) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.encodeChange(retptr, addHeapObject(change));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} change\n* @returns {any}\n*/\nexport function decodeChange(change) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeChange(retptr, addHeapObject(change));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @returns {SyncState}\n*/\nexport function initSyncState() {\n    const ret = wasm.initSyncState();\n    return SyncState.__wrap(ret);\n}\n\n/**\n* @param {any} state\n* @returns {SyncState}\n*/\nexport function importSyncState(state) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.importSyncState(retptr, addHeapObject(state));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return SyncState.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {SyncState} state\n* @returns {any}\n*/\nexport function exportSyncState(state) {\n    _assertClass(state, SyncState);\n    const ret = wasm.exportSyncState(state.__wbg_ptr);\n    return takeObject(ret);\n}\n\n/**\n* @param {any} message\n* @returns {Uint8Array}\n*/\nexport function encodeSyncMessage(message) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.encodeSyncMessage(retptr, addHeapObject(message));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {Uint8Array} msg\n* @returns {any}\n*/\nexport function decodeSyncMessage(msg) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeSyncMessage(retptr, addHeapObject(msg));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return takeObject(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n* @param {SyncState} state\n* @returns {Uint8Array}\n*/\nexport function encodeSyncState(state) {\n    _assertClass(state, SyncState);\n    const ret = wasm.encodeSyncState(state.__wbg_ptr);\n    return takeObject(ret);\n}\n\n/**\n* @param {Uint8Array} data\n* @returns {SyncState}\n*/\nexport function decodeSyncState(data) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.decodeSyncState(retptr, addHeapObject(data));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return SyncState.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n* How text is represented in materialized objects on the JS side\n*/\nexport const TextRepresentation = Object.freeze({\n/**\n* As an array of characters and objects\n*/\nArray:0,\"0\":\"Array\",\n/**\n* As a single JS string\n*/\nString:1,\"1\":\"String\", });\n\nconst AutomergeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_automerge_free(ptr >>> 0));\n/**\n*/\nexport class Automerge {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Automerge.prototype);\n        obj.__wbg_ptr = ptr;\n        AutomergeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        AutomergeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_automerge_free(ptr);\n    }\n    /**\n    * @param {string | undefined} actor\n    * @param {TextRepresentation} text_rep\n    * @returns {Automerge}\n    */\n    static new(actor, text_rep) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_new(retptr, ptr0, len0, text_rep);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} [actor]\n    * @returns {Automerge}\n    */\n    clone(actor) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_clone(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} actor\n    * @param {any} heads\n    * @returns {Automerge}\n    */\n    fork(actor, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            var ptr0 = isLikeNone(actor) ? 0 : passStringToWasm0(actor, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            var len0 = WASM_VECTOR_LEN;\n            wasm.automerge_fork(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Automerge.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    pendingOps() {\n        const ret = wasm.automerge_pendingOps(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {string | undefined} [message]\n    * @param {number | undefined} [time]\n    * @returns {any}\n    */\n    commit(message, time) {\n        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_commit(this.__wbg_ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Automerge} other\n    * @returns {Array<any>}\n    */\n    merge(other) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(other, Automerge);\n            wasm.automerge_merge(retptr, this.__wbg_ptr, other.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number}\n    */\n    rollback() {\n        const ret = wasm.automerge_rollback(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} [heads]\n    * @returns {Array<any>}\n    */\n    keys(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_keys(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} [heads]\n    * @returns {string}\n    */\n    text(obj, heads) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_text(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} [heads]\n    * @returns {Array<any>}\n    */\n    spans(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_spans(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} start\n    * @param {number} delete_count\n    * @param {any} text\n    */\n    splice(obj, start, delete_count, text) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_splice(retptr, this.__wbg_ptr, addHeapObject(obj), start, delete_count, addHeapObject(text));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} new_text\n    */\n    updateText(obj, new_text) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_updateText(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(new_text));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} args\n    */\n    updateSpans(obj, args) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_updateSpans(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(args));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} value\n    * @param {any} datatype\n    */\n    push(obj, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_push(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} value\n    * @returns {string | undefined}\n    */\n    pushObject(obj, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_pushObject(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {any} value\n    * @param {any} datatype\n    */\n    insert(obj, index, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_insert(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {any} args\n    */\n    splitBlock(obj, index, args) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_splitBlock(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(args));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} text\n    * @param {number} index\n    */\n    joinBlock(text, index) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_joinBlock(retptr, this.__wbg_ptr, addHeapObject(text), index);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} text\n    * @param {number} index\n    * @param {any} args\n    */\n    updateBlock(text, index, args) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_updateBlock(retptr, this.__wbg_ptr, addHeapObject(text), index, addHeapObject(args));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} text\n    * @param {number} index\n    * @param {Array<any> | undefined} [heads]\n    * @returns {any}\n    */\n    getBlock(text, index, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getBlock(retptr, this.__wbg_ptr, addHeapObject(text), index, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {any} value\n    * @returns {string | undefined}\n    */\n    insertObject(obj, index, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_insertObject(retptr, this.__wbg_ptr, addHeapObject(obj), index, addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            let v1;\n            if (r0 !== 0) {\n                v1 = getStringFromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 1, 1);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    * @param {any} datatype\n    */\n    put(obj, prop, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_put(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    * @returns {any}\n    */\n    putObject(obj, prop, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_putObject(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {any} value\n    */\n    increment(obj, prop, value) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_increment(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), addHeapObject(value));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {Array<any> | undefined} [heads]\n    * @returns {any}\n    */\n    get(obj, prop, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_get(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    * @param {Array<any> | undefined} [heads]\n    * @returns {any}\n    */\n    getWithType(obj, prop, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getWithType(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} [heads]\n    * @returns {object}\n    */\n    objInfo(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_objInfo(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} arg\n    * @param {Array<any> | undefined} [heads]\n    * @returns {Array<any>}\n    */\n    getAll(obj, arg, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getAll(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(arg), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} enable\n    * @returns {any}\n    */\n    enableFreeze(enable) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_enableFreeze(retptr, this.__wbg_ptr, addHeapObject(enable));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} datatype\n    * @param {any} export_function\n    * @param {any} import_function\n    */\n    registerDatatype(datatype, export_function, import_function) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_registerDatatype(retptr, this.__wbg_ptr, addHeapObject(datatype), addHeapObject(export_function), addHeapObject(import_function));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} object\n    * @param {any} meta\n    * @returns {any}\n    */\n    applyPatches(object, meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_applyPatches(retptr, this.__wbg_ptr, addHeapObject(object), addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} object\n    * @param {any} meta\n    * @returns {any}\n    */\n    applyAndReturnPatches(object, meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_applyAndReturnPatches(retptr, this.__wbg_ptr, addHeapObject(object), addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Array<any>}\n    */\n    diffIncremental() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_diffIncremental(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    */\n    updateDiffCursor() {\n        wasm.automerge_updateDiffCursor(this.__wbg_ptr);\n    }\n    /**\n    */\n    resetDiffCursor() {\n        wasm.automerge_resetDiffCursor(this.__wbg_ptr);\n    }\n    /**\n    * @param {Array<any>} before\n    * @param {Array<any>} after\n    * @returns {Array<any>}\n    */\n    diff(before, after) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_diff(retptr, this.__wbg_ptr, addHeapObject(before), addHeapObject(after));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Array<any>} heads\n    */\n    isolate(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_isolate(retptr, this.__wbg_ptr, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    */\n    integrate() {\n        wasm.automerge_integrate(this.__wbg_ptr);\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} [heads]\n    * @returns {number}\n    */\n    length(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_length(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getFloat64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} prop\n    */\n    delete(obj, prop) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_delete(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(prop));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    save() {\n        const ret = wasm.automerge_save(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveIncremental() {\n        const ret = wasm.automerge_saveIncremental(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Array<any>} heads\n    * @returns {Uint8Array}\n    */\n    saveSince(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_saveSince(retptr, this.__wbg_ptr, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveNoCompress() {\n        const ret = wasm.automerge_saveNoCompress(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Uint8Array}\n    */\n    saveAndVerify() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_saveAndVerify(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {number}\n    */\n    loadIncremental(data) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_loadIncremental(retptr, this.__wbg_ptr, addHeapObject(data));\n            var r0 = getFloat64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} changes\n    */\n    applyChanges(changes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_applyChanges(retptr, this.__wbg_ptr, addHeapObject(changes));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} have_deps\n    * @returns {Array<any>}\n    */\n    getChanges(have_deps) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getChanges(retptr, this.__wbg_ptr, addHeapObject(have_deps));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} hash\n    * @returns {any}\n    */\n    getChangeByHash(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getChangeByHash(retptr, this.__wbg_ptr, addHeapObject(hash));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} hash\n    * @returns {any}\n    */\n    getDecodedChangeByHash(hash) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getDecodedChangeByHash(retptr, this.__wbg_ptr, addHeapObject(hash));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {Automerge} other\n    * @returns {Array<any>}\n    */\n    getChangesAdded(other) {\n        _assertClass(other, Automerge);\n        const ret = wasm.automerge_getChangesAdded(this.__wbg_ptr, other.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Array<any>}\n    */\n    getHeads() {\n        const ret = wasm.automerge_getHeads(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    getActorId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getActorId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {any}\n    */\n    getLastLocalChange() {\n        const ret = wasm.automerge_getLastLocalChange(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    */\n    dump() {\n        wasm.automerge_dump(this.__wbg_ptr);\n    }\n    /**\n    * @param {Array<any> | undefined} [heads]\n    * @returns {Array<any>}\n    */\n    getMissingDeps(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getMissingDeps(retptr, this.__wbg_ptr, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SyncState} state\n    * @param {Uint8Array} message\n    */\n    receiveSyncMessage(state, message) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(state, SyncState);\n            wasm.automerge_receiveSyncMessage(retptr, this.__wbg_ptr, state.__wbg_ptr, addHeapObject(message));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SyncState} state\n    * @returns {any}\n    */\n    generateSyncMessage(state) {\n        _assertClass(state, SyncState);\n        const ret = wasm.automerge_generateSyncMessage(this.__wbg_ptr, state.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} meta\n    * @returns {any}\n    */\n    toJS(meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_toJS(retptr, this.__wbg_ptr, addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} heads\n    * @param {any} meta\n    * @returns {any}\n    */\n    materialize(obj, heads, meta) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_materialize(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads), addHeapObject(meta));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {Array<any> | undefined} [heads]\n    * @returns {string}\n    */\n    getCursor(obj, index, heads) {\n        let deferred2_0;\n        let deferred2_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getCursor(retptr, this.__wbg_ptr, addHeapObject(obj), index, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr1 = r0;\n            var len1 = r1;\n            if (r3) {\n                ptr1 = 0; len1 = 0;\n                throw takeObject(r2);\n            }\n            deferred2_0 = ptr1;\n            deferred2_1 = len1;\n            return getStringFromWasm0(ptr1, len1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} cursor\n    * @param {Array<any> | undefined} [heads]\n    * @returns {number}\n    */\n    getCursorPosition(obj, cursor, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_getCursorPosition(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(cursor), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getFloat64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return r0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {string | undefined} [message]\n    * @param {number | undefined} [time]\n    * @returns {any}\n    */\n    emptyChange(message, time) {\n        var ptr0 = isLikeNone(message) ? 0 : passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        const ret = wasm.automerge_emptyChange(this.__wbg_ptr, ptr0, len0, !isLikeNone(time), isLikeNone(time) ? 0 : time);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} obj\n    * @param {any} range\n    * @param {any} name\n    * @param {any} value\n    * @param {any} datatype\n    */\n    mark(obj, range, name, value, datatype) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_mark(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(range), addHeapObject(name), addHeapObject(value), addHeapObject(datatype));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {any} range\n    * @param {any} name\n    */\n    unmark(obj, range, name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_unmark(retptr, this.__wbg_ptr, addHeapObject(obj), addHeapObject(range), addHeapObject(name));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {Array<any> | undefined} [heads]\n    * @returns {any}\n    */\n    marks(obj, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_marks(retptr, this.__wbg_ptr, addHeapObject(obj), isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} obj\n    * @param {number} index\n    * @param {Array<any> | undefined} [heads]\n    * @returns {object}\n    */\n    marksAt(obj, index, heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.automerge_marksAt(retptr, this.__wbg_ptr, addHeapObject(obj), index, isLikeNone(heads) ? 0 : addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {SyncState} state\n    * @returns {any}\n    */\n    hasOurChanges(state) {\n        _assertClass(state, SyncState);\n        const ret = wasm.automerge_hasOurChanges(this.__wbg_ptr, state.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    topoHistoryTraversal() {\n        const ret = wasm.automerge_topoHistoryTraversal(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    stats() {\n        const ret = wasm.automerge_stats(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst SyncStateFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_syncstate_free(ptr >>> 0));\n/**\n*/\nexport class SyncState {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(SyncState.prototype);\n        obj.__wbg_ptr = ptr;\n        SyncStateFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        SyncStateFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_syncstate_free(ptr);\n    }\n    /**\n    * @returns {any}\n    */\n    get sharedHeads() {\n        const ret = wasm.syncstate_sharedHeads(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    get lastSentHeads() {\n        const ret = wasm.syncstate_lastSentHeads(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {any} heads\n    */\n    set lastSentHeads(heads) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncstate_set_lastSentHeads(retptr, this.__wbg_ptr, addHeapObject(heads));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {any} hashes\n    */\n    set sentHashes(hashes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.syncstate_set_sentHashes(retptr, this.__wbg_ptr, addHeapObject(hashes));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {SyncState}\n    */\n    clone() {\n        const ret = wasm.syncstate_clone(this.__wbg_ptr);\n        return SyncState.__wrap(ret);\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_null = function(arg0) {\n        const ret = getObject(arg0) === null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_array = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = JSON.stringify(obj === undefined ? null : obj);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_new_abda76e883ba8a5f = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {\n        const ret = getObject(arg0) == getObject(arg1);\n        return ret;\n    };\n    imports.wbg.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {\n        const ret = String(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {\n        const ret = BigInt.asUintN(64, arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_20cbc34131e76824 = function(arg0, arg1, arg2) {\n        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_getRandomValues_3aa56aa6edec874c = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_randomFillSync_5c9c955aa56b6049 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_crypto_1d1f22824a6a080c = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_process_4a72847cc503995b = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_f686565e586dd935 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_104a2ff8d6ea03a2 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_cca90b1a94a0255b = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_msCrypto_eb05e62b530a1508 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_log_5bb5f88f245d7762 = function(arg0) {\n        console.log(getObject(arg0));\n    };\n    imports.wbg.__wbg_log_1746d5c75ec89963 = function(arg0, arg1) {\n        console.log(getObject(arg0), getObject(arg1));\n    };\n    imports.wbg.__wbg_get_bd8e338fbd5f5cc8 = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_cd7af8117672b8b8 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_new_16b304a2cfa7ff4a = function() {\n        const ret = new Array();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newnoargs_e258087cd0daa0ea = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_40fc327bfc8770e6 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_196c84450b364254 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_298b57d23c0fc80c = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_d93c65011f51a456 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_iterator_2cee6dadfd956dfa = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_e3c254076557e348 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_27c0f87801dedf93 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_72fb9a18b5ae2624 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_dee433d4c85c9387 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_set_d4638f722068f043 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_from_89e3fc3ba5e6fb48 = function(arg0) {\n        const ret = Array.from(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_isArray_2ab64d95e09ea0ae = function(arg0) {\n        const ret = Array.isArray(getObject(arg0));\n        return ret;\n    };\n    imports.wbg.__wbg_push_a5b05aedc7234f9f = function(arg0, arg1) {\n        const ret = getObject(arg0).push(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_unshift_e22df4b34bcf5070 = function(arg0, arg1) {\n        const ret = getObject(arg0).unshift(getObject(arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_ArrayBuffer_836825be07d4c9d2 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof ArrayBuffer;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_new_28c511d9baebfa89 = function(arg0, arg1) {\n        const ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_b3ca7c6051f9bec1 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Date_f65cf97fb83fc369 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Date;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_getTime_2bc4375165f02d15 = function(arg0) {\n        const ret = getObject(arg0).getTime();\n        return ret;\n    };\n    imports.wbg.__wbg_new_cf3ec55744a78578 = function(arg0) {\n        const ret = new Date(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_instanceof_Object_71ca3c0a59266746 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Object;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_assign_496d2d14fecafbcf = function(arg0, arg1) {\n        const ret = Object.assign(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_defineProperty_cc00e2de8a0f5141 = function(arg0, arg1, arg2) {\n        const ret = Object.defineProperty(getObject(arg0), getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_entries_95cc2c823b285a09 = function(arg0) {\n        const ret = Object.entries(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_freeze_cc6bc19f75299986 = function(arg0) {\n        const ret = Object.freeze(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_keys_91e412b4b222659f = function(arg0) {\n        const ret = Object.keys(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_values_9c75e6e2bfbdb70d = function(arg0) {\n        const ret = Object.values(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_dd6a5dd7b538af21 = function(arg0, arg1) {\n        const ret = new RangeError(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_apply_0a5aa603881e6d79 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.apply(getObject(arg0), getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_deleteProperty_13e721a56f19e842 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.deleteProperty(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_ownKeys_658942b7f28d1fe9 = function() { return handleError(function (arg0) {\n        const ret = Reflect.ownKeys(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_set_1f9b04f170055d33 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_buffer_12d079cc21e14bdb = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_concat_3de229fe4fe90fea = function(arg0, arg1) {\n        const ret = getObject(arg0).concat(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_slice_52fb626ffdc8da8f = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).slice(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_for_27c67e2dbdce22f6 = function(arg0, arg1) {\n        const ret = Symbol.for(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_toString_7df3c77999517c20 = function(arg0) {\n        const ret = getObject(arg0).toString();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_ce0dbfc45cf2f5be = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_c6fb939a7f436783 = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_d1e6af4856ba331b = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_207b558942527489 = function() { return handleError(function () {\n        const ret = global.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_63b92bc8671ed464 = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_c20a40f15020d68a = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_2b3bbecd033d19f6 = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Uint8Array;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_e9b4878cebadb3d3 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_subarray_a1f73cd4b5b42fe1 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedFloat64Memory0 = null;\n    cachedInt32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n    if (wasm !== undefined) return wasm;\n\n    if (typeof input === 'undefined') {\n        input = new URL('automerge_wasm_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync }\nexport default __wbg_init;\n", "import { default as initWasm } from \"./wasm_bindgen_output/web/automerge_wasm.js\";\nimport * as WasmApi from \"./wasm_bindgen_output/web/automerge_wasm.js\";\nlet _initialized = false;\nlet _initializeListeners = [];\nexport function UseApi(api) {\n    for (const k in api) {\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi,@typescript-eslint/no-explicit-any\n        ;\n        ApiHandler[k] = api[k];\n    }\n    _initialized = true;\n    for (const listener of _initializeListeners) {\n        listener();\n    }\n}\n/* eslint-disable */\nexport const ApiHandler = {\n    create(options) {\n        throw new RangeError(\"Automerge.use() not called\");\n    },\n    load(data, options) {\n        throw new RangeError(\"Automerge.use() not called (load)\");\n    },\n    encodeChange(change) {\n        throw new RangeError(\"Automerge.use() not called (encodeChange)\");\n    },\n    decodeChange(change) {\n        throw new RangeError(\"Automerge.use() not called (decodeChange)\");\n    },\n    initSyncState() {\n        throw new RangeError(\"Automerge.use() not called (initSyncState)\");\n    },\n    encodeSyncMessage(message) {\n        throw new RangeError(\"Automerge.use() not called (encodeSyncMessage)\");\n    },\n    decodeSyncMessage(msg) {\n        throw new RangeError(\"Automerge.use() not called (decodeSyncMessage)\");\n    },\n    encodeSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (encodeSyncState)\");\n    },\n    decodeSyncState(data) {\n        throw new RangeError(\"Automerge.use() not called (decodeSyncState)\");\n    },\n    exportSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (exportSyncState)\");\n    },\n    importSyncState(state) {\n        throw new RangeError(\"Automerge.use() not called (importSyncState)\");\n    },\n};\n/* eslint-enable */\n/**\n * Initialize the wasm module\n *\n * @param wasmBlob - The wasm module as a Uint8Array, Request, Promise<Uint8Array> or string. If this argument is a string then it is assumed to be a URL and the library will attempt to fetch the wasm module from that URL.\n *\n * @remarks\n * If you are using the `/slim` subpath export then this function must be\n * called before any other functions in the library. If you are using any of\n * the other subpath exports then it will have already been called for you.\n */\nexport function initializeWasm(wasmBlob) {\n    return initWasm(wasmBlob).then(_ => {\n        UseApi(WasmApi);\n    });\n}\n/**\n * Initialize the wasm module from a base64 encoded string\n *\n * @param wasmBase64 - The bytes of the wasm file as a base64 encoded string\n */\nexport function initializeBase64Wasm(wasmBase64) {\n    return initializeWasm(Uint8Array.from(atob(wasmBase64), c => c.charCodeAt(0)));\n}\n/**\n * A promise which resolves when the web assembly module has been initialized\n * (or immediately if it has already been initialized)\n */\nexport function wasmInitialized() {\n    if (_initialized)\n        return Promise.resolve();\n    return new Promise(resolve => {\n        _initializeListeners.push(resolve);\n    });\n}\n/**\n * Check if the wasm module has been initialized\n *\n * @returns true if the wasm module has been initialized\n */\nexport function isWasmInitialized() {\n    return _initialized;\n}\n", "/* eslint-disable  @typescript-eslint/no-explicit-any */\nimport { Text } from \"./text.js\";\nimport { getWriteableCounter } from \"./counter.js\";\nimport { STATE, TRACE, IS_PROXY, OBJECT_ID, CLEAR_CACHE, COUNTER, INT, UINT, F64, } from \"./constants.js\";\nimport { RawString } from \"./raw_string.js\";\nfunction parseListIndex(key) {\n    if (typeof key === \"string\" && /^[0-9]+$/.test(key))\n        key = parseInt(key, 10);\n    if (typeof key !== \"number\") {\n        return key;\n    }\n    if (key < 0 || isNaN(key) || key === Infinity || key === -Infinity) {\n        throw new RangeError(\"A list index must be positive, but you passed \" + key);\n    }\n    return key;\n}\nfunction valueAt(target, prop) {\n    const { context, objectId, path, textV2 } = target;\n    const value = context.getWithType(objectId, prop);\n    if (value === null) {\n        return;\n    }\n    const datatype = value[0];\n    const val = value[1];\n    switch (datatype) {\n        case undefined:\n            return;\n        case \"map\":\n            return mapProxy(context, val, textV2, [...path, prop]);\n        case \"list\":\n            return listProxy(context, val, textV2, [...path, prop]);\n        case \"text\":\n            if (textV2) {\n                return context.text(val);\n            }\n            else {\n                return textProxy(context, val, [\n                    ...path,\n                    prop,\n                ]);\n            }\n        case \"str\":\n            return val;\n        case \"uint\":\n            return val;\n        case \"int\":\n            return val;\n        case \"f64\":\n            return val;\n        case \"boolean\":\n            return val;\n        case \"null\":\n            return null;\n        case \"bytes\":\n            return val;\n        case \"timestamp\":\n            return val;\n        case \"counter\": {\n            const counter = getWriteableCounter(val, context, path, objectId, prop);\n            return counter;\n        }\n        default:\n            throw RangeError(`datatype ${datatype} unimplemented`);\n    }\n}\nfunction import_value(value, textV2, path, context) {\n    const type = typeof value;\n    switch (type) {\n        case \"object\":\n            if (value == null) {\n                return [null, \"null\"];\n            }\n            else if (value[UINT]) {\n                return [value.value, \"uint\"];\n            }\n            else if (value[INT]) {\n                return [value.value, \"int\"];\n            }\n            else if (value[F64]) {\n                return [value.value, \"f64\"];\n            }\n            else if (value[COUNTER]) {\n                return [value.value, \"counter\"];\n            }\n            else if (value instanceof Date) {\n                return [value.getTime(), \"timestamp\"];\n            }\n            else if (value instanceof RawString) {\n                return [value.toString(), \"str\"];\n            }\n            else if (value instanceof Text) {\n                return [value, \"text\"];\n            }\n            else if (value instanceof Uint8Array) {\n                return [value, \"bytes\"];\n            }\n            else if (value instanceof Array) {\n                return [value, \"list\"];\n            }\n            else if (Object.prototype.toString.call(value) === \"[object Object]\") {\n                return [value, \"map\"];\n            }\n            else if (isSameDocument(value, context)) {\n                throw new RangeError(\"Cannot create a reference to an existing document object\");\n            }\n            else {\n                throw new RangeError(`Cannot assign unknown object: ${value}`);\n            }\n        case \"boolean\":\n            return [value, \"boolean\"];\n        case \"number\":\n            if (Number.isInteger(value)) {\n                return [value, \"int\"];\n            }\n            else {\n                return [value, \"f64\"];\n            }\n        case \"string\":\n            if (textV2) {\n                return [value, \"text\"];\n            }\n            else {\n                return [value, \"str\"];\n            }\n        case \"undefined\":\n            throw new RangeError([\n                `Cannot assign undefined value at ${printPath(path)}, `,\n                \"because `undefined` is not a valid JSON data type. \",\n                \"You might consider setting the property's value to `null`, \",\n                \"or using `delete` to remove it altogether.\",\n            ].join(\"\"));\n        default:\n            throw new RangeError([\n                `Cannot assign ${type} value at ${printPath(path)}. `,\n                `All JSON primitive datatypes (object, array, string, number, boolean, null) `,\n                `are supported in an Automerge document; ${type} values are not. `,\n            ].join(\"\"));\n    }\n}\n// When we assign a value to a property in a proxy we recursively walk through\n// the value we are assigning and copy it into the document. This is generally\n// desirable behaviour. However, a very common bug is to accidentally assign a\n// value which is already in the document to another key within the same\n// document, this often leads to surprising behaviour where users expected to\n// _move_ the object, but it is instead copied. To avoid this we check if the\n// value is from the same document and if it is we throw an error, this means\n// we require an explicit Object.assign call to copy the object, thus avoiding\n// the footgun\nfunction isSameDocument(val, context) {\n    var _b, _c;\n    // Date is technically an object, but immutable, so allowing people to assign\n    // a date from one place in the document to another place in the document is\n    // not likely to be a bug\n    if (val instanceof Date) {\n        return false;\n    }\n    // this depends on __wbg_ptr being the wasm pointer\n    // a new version of wasm-bindgen will break this\n    // but the tests should expose the break\n    if (val && ((_c = (_b = val[STATE]) === null || _b === void 0 ? void 0 : _b.handle) === null || _c === void 0 ? void 0 : _c.__wbg_ptr) === context.__wbg_ptr) {\n        return true;\n    }\n    return false;\n}\nconst MapHandler = {\n    get(target, key) {\n        const { context, objectId, cache } = target;\n        if (key === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (key === OBJECT_ID)\n            return objectId;\n        if (key === IS_PROXY)\n            return true;\n        if (key === TRACE)\n            return target.trace;\n        if (key === STATE)\n            return { handle: context, textV2: target.textV2 };\n        if (!cache[key]) {\n            cache[key] = valueAt(target, key);\n        }\n        return cache[key];\n    },\n    set(target, key, val) {\n        const { context, objectId, path, textV2 } = target;\n        target.cache = {}; // reset cache on set\n        if (isSameDocument(val, context)) {\n            throw new RangeError(\"Cannot create a reference to an existing document object\");\n        }\n        if (key === TRACE) {\n            target.trace = val;\n            return true;\n        }\n        if (key === CLEAR_CACHE) {\n            return true;\n        }\n        const [value, datatype] = import_value(val, textV2, [...path, key], context);\n        switch (datatype) {\n            case \"list\": {\n                const list = context.putObject(objectId, key, []);\n                const proxyList = listProxy(context, list, textV2, [...path, key]);\n                for (let i = 0; i < value.length; i++) {\n                    proxyList[i] = value[i];\n                }\n                break;\n            }\n            case \"text\": {\n                if (textV2) {\n                    assertString(value);\n                    context.putObject(objectId, key, value);\n                }\n                else {\n                    assertText(value);\n                    const text = context.putObject(objectId, key, \"\");\n                    const proxyText = textProxy(context, text, [...path, key]);\n                    proxyText.splice(0, 0, ...value);\n                }\n                break;\n            }\n            case \"map\": {\n                const map = context.putObject(objectId, key, {});\n                const proxyMap = mapProxy(context, map, textV2, [...path, key]);\n                for (const key in value) {\n                    proxyMap[key] = value[key];\n                }\n                break;\n            }\n            default:\n                context.put(objectId, key, value, datatype);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        const { context, objectId } = target;\n        target.cache = {}; // reset cache on delete\n        context.delete(objectId, key);\n        return true;\n    },\n    has(target, key) {\n        const value = this.get(target, key);\n        return value !== undefined;\n    },\n    getOwnPropertyDescriptor(target, key) {\n        // const { context, objectId } = target\n        const value = this.get(target, key);\n        if (typeof value !== \"undefined\") {\n            return {\n                configurable: true,\n                enumerable: true,\n                value,\n            };\n        }\n    },\n    ownKeys(target) {\n        const { context, objectId } = target;\n        // FIXME - this is a tmp workaround until fix the dupe key bug in keys()\n        const keys = context.keys(objectId);\n        return [...new Set(keys)];\n    },\n};\nconst ListHandler = {\n    get(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (index === Symbol.hasInstance) {\n            return (instance) => {\n                return Array.isArray(instance);\n            };\n        }\n        if (index === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (index === OBJECT_ID)\n            return objectId;\n        if (index === IS_PROXY)\n            return true;\n        if (index === TRACE)\n            return target.trace;\n        if (index === STATE)\n            return { handle: context };\n        if (index === \"length\")\n            return context.length(objectId);\n        if (typeof index === \"number\") {\n            return valueAt(target, index);\n        }\n        else {\n            return listMethods(target)[index];\n        }\n    },\n    set(target, index, val) {\n        const { context, objectId, path, textV2 } = target;\n        index = parseListIndex(index);\n        if (isSameDocument(val, context)) {\n            throw new RangeError(\"Cannot create a reference to an existing document object\");\n        }\n        if (index === CLEAR_CACHE) {\n            return true;\n        }\n        if (index === TRACE) {\n            target.trace = val;\n            return true;\n        }\n        if (typeof index == \"string\") {\n            throw new RangeError(\"list index must be a number\");\n        }\n        const [value, datatype] = import_value(val, textV2, [...path, index], context);\n        switch (datatype) {\n            case \"list\": {\n                let list;\n                if (index >= context.length(objectId)) {\n                    list = context.insertObject(objectId, index, []);\n                }\n                else {\n                    list = context.putObject(objectId, index, []);\n                }\n                const proxyList = listProxy(context, list, textV2, [...path, index]);\n                proxyList.splice(0, 0, ...value);\n                break;\n            }\n            case \"text\": {\n                if (textV2) {\n                    assertString(value);\n                    if (index >= context.length(objectId)) {\n                        context.insertObject(objectId, index, value);\n                    }\n                    else {\n                        context.putObject(objectId, index, value);\n                    }\n                }\n                else {\n                    let text;\n                    assertText(value);\n                    if (index >= context.length(objectId)) {\n                        text = context.insertObject(objectId, index, \"\");\n                    }\n                    else {\n                        text = context.putObject(objectId, index, \"\");\n                    }\n                    const proxyText = textProxy(context, text, [...path, index]);\n                    proxyText.splice(0, 0, ...value);\n                }\n                break;\n            }\n            case \"map\": {\n                let map;\n                if (index >= context.length(objectId)) {\n                    map = context.insertObject(objectId, index, {});\n                }\n                else {\n                    map = context.putObject(objectId, index, {});\n                }\n                const proxyMap = mapProxy(context, map, textV2, [...path, index]);\n                for (const key in value) {\n                    proxyMap[key] = value[key];\n                }\n                break;\n            }\n            default:\n                if (index >= context.length(objectId)) {\n                    context.insert(objectId, index, value, datatype);\n                }\n                else {\n                    context.put(objectId, index, value, datatype);\n                }\n        }\n        return true;\n    },\n    deleteProperty(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        const elem = context.get(objectId, index);\n        if (elem != null && elem[0] == \"counter\") {\n            throw new TypeError(\"Unsupported operation: deleting a counter from a list\");\n        }\n        context.delete(objectId, index);\n        return true;\n    },\n    has(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (typeof index === \"number\") {\n            return index < context.length(objectId);\n        }\n        return index === \"length\";\n    },\n    getOwnPropertyDescriptor(target, index) {\n        const { context, objectId } = target;\n        if (index === \"length\")\n            return { writable: true, value: context.length(objectId) };\n        if (index === OBJECT_ID)\n            return { configurable: false, enumerable: false, value: objectId };\n        index = parseListIndex(index);\n        const value = valueAt(target, index);\n        return { configurable: true, enumerable: true, value };\n    },\n    getPrototypeOf(target) {\n        return Object.getPrototypeOf(target);\n    },\n    ownKeys( /*target*/) {\n        const keys = [];\n        // uncommenting this causes assert.deepEqual() to fail when comparing to a pojo array\n        // but not uncommenting it causes for (i in list) {} to not enumerate values properly\n        //const {context, objectId } = target\n        //for (let i = 0; i < target.context.length(objectId); i++) { keys.push(i.toString()) }\n        keys.push(\"length\");\n        return keys;\n    },\n};\nconst TextHandler = Object.assign({}, ListHandler, {\n    get(target, index) {\n        const { context, objectId } = target;\n        index = parseListIndex(index);\n        if (index === Symbol.hasInstance) {\n            return (instance) => {\n                return Array.isArray(instance);\n            };\n        }\n        if (index === Symbol.toStringTag) {\n            return target[Symbol.toStringTag];\n        }\n        if (index === OBJECT_ID)\n            return objectId;\n        if (index === IS_PROXY)\n            return true;\n        if (index === TRACE)\n            return target.trace;\n        if (index === STATE)\n            return { handle: context };\n        if (index === \"length\")\n            return context.length(objectId);\n        if (typeof index === \"number\") {\n            return valueAt(target, index);\n        }\n        else {\n            return textMethods(target)[index] || listMethods(target)[index];\n        }\n    },\n    getPrototypeOf( /*target*/) {\n        return Object.getPrototypeOf(new Text());\n    },\n});\nexport function mapProxy(context, objectId, textV2, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n        textV2,\n    };\n    const proxied = {};\n    Object.assign(proxied, target);\n    const result = new Proxy(proxied, MapHandler);\n    // conversion through unknown is necessary because the types are so different\n    return result;\n}\nexport function listProxy(context, objectId, textV2, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n        textV2,\n    };\n    const proxied = [];\n    Object.assign(proxied, target);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return new Proxy(proxied, ListHandler);\n}\nexport function textProxy(context, objectId, path) {\n    const target = {\n        context,\n        objectId,\n        path: path || [],\n        cache: {},\n        textV2: false,\n    };\n    const proxied = {};\n    Object.assign(proxied, target);\n    return new Proxy(proxied, TextHandler);\n}\nexport function rootProxy(context, textV2) {\n    /* eslint-disable-next-line */\n    return mapProxy(context, \"_root\", textV2, []);\n}\nfunction listMethods(target) {\n    const { context, objectId, path, textV2 } = target;\n    const methods = {\n        deleteAt(index, numDelete) {\n            if (typeof numDelete === \"number\") {\n                context.splice(objectId, index, numDelete);\n            }\n            else {\n                context.delete(objectId, index);\n            }\n            return this;\n        },\n        fill(val, start, end) {\n            const [value, datatype] = import_value(val, textV2, [...path, start], context);\n            const length = context.length(objectId);\n            start = parseListIndex(start || 0);\n            end = parseListIndex(end || length);\n            for (let i = start; i < Math.min(end, length); i++) {\n                if (datatype === \"list\" || datatype === \"map\") {\n                    context.putObject(objectId, i, value);\n                }\n                else if (datatype === \"text\") {\n                    if (textV2) {\n                        assertString(value);\n                        context.putObject(objectId, i, value);\n                    }\n                    else {\n                        assertText(value);\n                        const text = context.putObject(objectId, i, \"\");\n                        const proxyText = textProxy(context, text, [...path, i]);\n                        for (let i = 0; i < value.length; i++) {\n                            proxyText[i] = value.get(i);\n                        }\n                    }\n                }\n                else {\n                    context.put(objectId, i, value, datatype);\n                }\n            }\n            return this;\n        },\n        indexOf(o, start = 0) {\n            const length = context.length(objectId);\n            for (let i = start; i < length; i++) {\n                const value = context.getWithType(objectId, i);\n                if (value && (value[1] === o[OBJECT_ID] || value[1] === o)) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n        insertAt(index, ...values) {\n            this.splice(index, 0, ...values);\n            return this;\n        },\n        pop() {\n            const length = context.length(objectId);\n            if (length == 0) {\n                return undefined;\n            }\n            const last = valueAt(target, length - 1);\n            context.delete(objectId, length - 1);\n            return last;\n        },\n        push(...values) {\n            const len = context.length(objectId);\n            this.splice(len, 0, ...values);\n            return context.length(objectId);\n        },\n        shift() {\n            if (context.length(objectId) == 0)\n                return;\n            const first = valueAt(target, 0);\n            context.delete(objectId, 0);\n            return first;\n        },\n        splice(index, del, ...vals) {\n            index = parseListIndex(index);\n            // if del is undefined, delete until the end of the list\n            if (typeof del !== \"number\") {\n                del = context.length(objectId) - index;\n            }\n            del = parseListIndex(del);\n            for (const val of vals) {\n                if (isSameDocument(val, context)) {\n                    throw new RangeError(\"Cannot create a reference to an existing document object\");\n                }\n            }\n            const result = [];\n            for (let i = 0; i < del; i++) {\n                const value = valueAt(target, index);\n                if (value !== undefined) {\n                    result.push(value);\n                }\n                context.delete(objectId, index);\n            }\n            const values = vals.map((val, index) => {\n                try {\n                    return import_value(val, textV2, [...path], context);\n                }\n                catch (e) {\n                    if (e instanceof RangeError) {\n                        throw new RangeError(`${e.message} (at index ${index} in the input)`);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            });\n            for (const [value, datatype] of values) {\n                switch (datatype) {\n                    case \"list\": {\n                        const list = context.insertObject(objectId, index, []);\n                        const proxyList = listProxy(context, list, textV2, [...path, index]);\n                        proxyList.splice(0, 0, ...value);\n                        break;\n                    }\n                    case \"text\": {\n                        if (textV2) {\n                            assertString(value);\n                            context.insertObject(objectId, index, value);\n                        }\n                        else {\n                            const text = context.insertObject(objectId, index, \"\");\n                            const proxyText = textProxy(context, text, [...path, index]);\n                            proxyText.splice(0, 0, ...value);\n                        }\n                        break;\n                    }\n                    case \"map\": {\n                        const map = context.insertObject(objectId, index, {});\n                        const proxyMap = mapProxy(context, map, textV2, [...path, index]);\n                        for (const key in value) {\n                            proxyMap[key] = value[key];\n                        }\n                        break;\n                    }\n                    default:\n                        context.insert(objectId, index, value, datatype);\n                }\n                index += 1;\n            }\n            return result;\n        },\n        unshift(...values) {\n            this.splice(0, 0, ...values);\n            return context.length(objectId);\n        },\n        entries() {\n            let i = 0;\n            const iterator = {\n                next: () => {\n                    const value = valueAt(target, i);\n                    if (value === undefined) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        return { value: [i++, value], done: false };\n                    }\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        keys() {\n            let i = 0;\n            const len = context.length(objectId);\n            const iterator = {\n                next: () => {\n                    if (i < len) {\n                        return { value: i++, done: false };\n                    }\n                    return { value: undefined, done: true };\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        values() {\n            let i = 0;\n            const iterator = {\n                next: () => {\n                    const value = valueAt(target, i++);\n                    if (value === undefined) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        return { value, done: false };\n                    }\n                },\n                [Symbol.iterator]() {\n                    return this;\n                },\n            };\n            return iterator;\n        },\n        toArray() {\n            const list = [];\n            let value;\n            do {\n                value = valueAt(target, list.length);\n                if (value !== undefined) {\n                    list.push(value);\n                }\n            } while (value !== undefined);\n            return list;\n        },\n        map(f) {\n            return this.toArray().map(f);\n        },\n        toString() {\n            return this.toArray().toString();\n        },\n        toLocaleString() {\n            return this.toArray().toLocaleString();\n        },\n        forEach(f) {\n            return this.toArray().forEach(f);\n        },\n        // todo: real concat function is different\n        concat(other) {\n            return this.toArray().concat(other);\n        },\n        every(f) {\n            return this.toArray().every(f);\n        },\n        filter(f) {\n            return this.toArray().filter(f);\n        },\n        find(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return v;\n                }\n                index += 1;\n            }\n        },\n        findIndex(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return index;\n                }\n                index += 1;\n            }\n            return -1;\n        },\n        includes(elem) {\n            return this.find(e => e === elem) !== undefined;\n        },\n        join(sep) {\n            return this.toArray().join(sep);\n        },\n        reduce(f, initialValue) {\n            return this.toArray().reduce(f, initialValue);\n        },\n        reduceRight(f, initialValue) {\n            return this.toArray().reduceRight(f, initialValue);\n        },\n        lastIndexOf(search, fromIndex = +Infinity) {\n            // this can be faster\n            return this.toArray().lastIndexOf(search, fromIndex);\n        },\n        slice(index, num) {\n            return this.toArray().slice(index, num);\n        },\n        some(f) {\n            let index = 0;\n            for (const v of this) {\n                if (f(v, index)) {\n                    return true;\n                }\n                index += 1;\n            }\n            return false;\n        },\n        [Symbol.iterator]: function* () {\n            let i = 0;\n            let value = valueAt(target, i);\n            while (value !== undefined) {\n                yield value;\n                i += 1;\n                value = valueAt(target, i);\n            }\n        },\n    };\n    return methods;\n}\nfunction textMethods(target) {\n    const { context, objectId } = target;\n    const methods = {\n        set(index, value) {\n            return (this[index] = value);\n        },\n        get(index) {\n            return this[index];\n        },\n        toString() {\n            return context.text(objectId).replace(//g, \"\");\n        },\n        toSpans() {\n            const spans = [];\n            let chars = \"\";\n            const length = context.length(objectId);\n            for (let i = 0; i < length; i++) {\n                const value = this[i];\n                if (typeof value === \"string\") {\n                    chars += value;\n                }\n                else {\n                    if (chars.length > 0) {\n                        spans.push(chars);\n                        chars = \"\";\n                    }\n                    spans.push(value);\n                }\n            }\n            if (chars.length > 0) {\n                spans.push(chars);\n            }\n            return spans;\n        },\n        toJSON() {\n            return this.toString();\n        },\n        indexOf(o, start = 0) {\n            const text = context.text(objectId);\n            return text.indexOf(o, start);\n        },\n        insertAt(index, ...values) {\n            if (values.every(v => typeof v === \"string\")) {\n                context.splice(objectId, index, 0, values.join(\"\"));\n            }\n            else {\n                listMethods(target).insertAt(index, ...values);\n            }\n        },\n    };\n    return methods;\n}\nfunction assertText(value) {\n    if (!(value instanceof Text)) {\n        throw new Error(\"value was not a Text instance\");\n    }\n}\nfunction assertString(value) {\n    if (typeof value !== \"string\") {\n        throw new Error(\"value was not a string\");\n    }\n}\nfunction printPath(path) {\n    // print the path as a json pointer\n    const jsonPointerComponents = path.map(component => {\n        // if its a number just turn it into a string\n        if (typeof component === \"number\") {\n            return component.toString();\n        }\n        else if (typeof component === \"string\") {\n            // otherwise we have to escape `/` and `~` characters\n            return component.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n        }\n    });\n    if (path.length === 0) {\n        return \"\";\n    }\n    else {\n        return \"/\" + jsonPointerComponents.join(\"/\");\n    }\n}\n", "import { CLEAR_CACHE, IS_PROXY, OBJECT_ID, STATE, TRACE } from \"./constants.js\";\nexport function _state(doc, checkroot = true) {\n    if (typeof doc !== \"object\") {\n        throw new RangeError(\"must be the document root\");\n    }\n    const state = Reflect.get(doc, STATE);\n    if (state === undefined ||\n        state == null ||\n        (checkroot && _obj(doc) !== \"_root\")) {\n        throw new RangeError(\"must be the document root\");\n    }\n    return state;\n}\nexport function _clear_cache(doc) {\n    Reflect.set(doc, CLEAR_CACHE, true);\n}\nexport function _trace(doc) {\n    return Reflect.get(doc, TRACE);\n}\nexport function _obj(doc) {\n    if (!(typeof doc === \"object\") || doc === null) {\n        return null;\n    }\n    return Reflect.get(doc, OBJECT_ID);\n}\nexport function _is_proxy(doc) {\n    return !!Reflect.get(doc, IS_PROXY);\n}\n", "import { Counter } from \"./types.js\";\nimport { Text } from \"./text.js\";\nimport { mapProxy, listProxy } from \"./proxies.js\";\nexport function stableConflictAt(context, objectId, prop) {\n    return conflictAt(context, objectId, prop, true, (context, conflictId) => {\n        return new Text(context.text(conflictId));\n    });\n}\nexport function unstableConflictAt(context, objectId, prop) {\n    return conflictAt(context, objectId, prop, true, (context, conflictId) => {\n        return context.text(conflictId);\n    });\n}\nfunction conflictAt(context, objectId, prop, textV2, handleText) {\n    const values = context.getAll(objectId, prop);\n    if (values.length <= 1) {\n        return;\n    }\n    const result = {};\n    for (const fullVal of values) {\n        switch (fullVal[0]) {\n            case \"map\":\n                result[fullVal[1]] = mapProxy(context, fullVal[1], textV2, [prop]);\n                break;\n            case \"list\":\n                result[fullVal[1]] = listProxy(context, fullVal[1], textV2, [prop]);\n                break;\n            case \"text\":\n                result[fullVal[1]] = handleText(context, fullVal[1]);\n                break;\n            case \"str\":\n            case \"uint\":\n            case \"int\":\n            case \"f64\":\n            case \"boolean\":\n            case \"bytes\":\n            case \"null\":\n                result[fullVal[2]] = fullVal[1];\n                break;\n            case \"counter\":\n                result[fullVal[2]] = new Counter(fullVal[1]);\n                break;\n            case \"timestamp\":\n                result[fullVal[2]] = new Date(fullVal[1]);\n                break;\n            default:\n                throw RangeError(`datatype ${fullVal[0]} unimplemented`);\n        }\n    }\n    return result;\n}\n", "var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\n/** @hidden **/\nexport { /** @hidden */ uuid } from \"./uuid.js\";\nimport { rootProxy } from \"./proxies.js\";\nimport { STATE } from \"./constants.js\";\nimport { Counter, } from \"./types.js\";\nexport { Counter, Int, Uint, Float64, } from \"./types.js\";\nimport { Text } from \"./text.js\";\nexport { Text } from \"./text.js\";\nconst SyncStateSymbol = Symbol(\"_syncstate\");\nimport { ApiHandler, UseApi } from \"./low_level.js\";\nexport { initializeWasm, initializeBase64Wasm, wasmInitialized, isWasmInitialized, } from \"./low_level.js\";\nimport { RawString } from \"./raw_string.js\";\nimport { _state, _is_proxy, _trace, _obj } from \"./internal_state.js\";\nimport { stableConflictAt } from \"./conflicts.js\";\n/**\n * Function for use in {@link change} which inserts values into a list at a given index\n * @param list\n * @param index\n * @param values\n */\nexport function insertAt(list, index, ...values) {\n    if (!_is_proxy(list)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    ;\n    list.insertAt(index, ...values);\n}\n/**\n * Function for use in {@link change} which deletes values from a list at a given index\n * @param list\n * @param index\n * @param numDelete\n */\nexport function deleteAt(list, index, numDelete) {\n    if (!_is_proxy(list)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    ;\n    list.deleteAt(index, numDelete);\n}\n/** @hidden **/\nexport function use(api) {\n    UseApi(api);\n}\n/** @hidden */\nexport function getBackend(doc) {\n    return _state(doc).handle;\n}\nfunction importOpts(_actor) {\n    if (typeof _actor === \"object\") {\n        return _actor;\n    }\n    else {\n        return { actor: _actor };\n    }\n}\n/**\n * Create a new automerge document\n *\n * @typeParam T - The type of value contained in the document. This will be the\n *     type that is passed to the change closure in {@link change}\n * @param _opts - Either an actorId or an {@link InitOptions} (which may\n *     contain an actorId). If this is null the document will be initialised with a\n *     random actor ID\n */\nexport function init(_opts) {\n    const opts = importOpts(_opts);\n    const freeze = !!opts.freeze;\n    const patchCallback = opts.patchCallback;\n    const text_v1 = !(opts.enableTextV2 || false);\n    const actor = opts.actor;\n    const handle = ApiHandler.create({ actor, text_v1 });\n    handle.enableFreeze(!!opts.freeze);\n    const textV2 = opts.enableTextV2 || false;\n    registerDatatypes(handle, textV2);\n    const doc = handle.materialize(\"/\", undefined, {\n        handle,\n        heads: undefined,\n        freeze,\n        patchCallback,\n        textV2,\n    });\n    return doc;\n}\n/**\n * Make an immutable view of an automerge document as at `heads`\n *\n * @remarks\n * The document returned from this function cannot be passed to {@link change}.\n * This is because it shares the same underlying memory as `doc`, but it is\n * consequently a very cheap copy.\n *\n * Note that this function will throw an error if any of the hashes in `heads`\n * are not in the document.\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to create a view of\n * @param heads - The hashes of the heads to create a view at\n */\nexport function view(doc, heads) {\n    const state = _state(doc);\n    const handle = state.handle;\n    return state.handle.materialize(\"/\", heads, Object.assign(Object.assign({}, state), { handle,\n        heads }));\n}\n/**\n * Make a full writable copy of an automerge document\n *\n * @remarks\n * Unlike {@link view} this function makes a full copy of the memory backing\n * the document and can thus be passed to {@link change}. It also generates a\n * new actor ID so that changes made in the new document do not create duplicate\n * sequence numbers with respect to the old document. If you need control over\n * the actor ID which is generated you can pass the actor ID as the second\n * argument\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to clone\n * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}\n */\nexport function clone(doc, _opts) {\n    const state = _state(doc);\n    const heads = state.heads;\n    const opts = importOpts(_opts);\n    const handle = state.handle.fork(opts.actor, heads);\n    handle.updateDiffCursor();\n    // `change` uses the presence of state.heads to determine if we are in a view\n    // set it to undefined to indicate that this is a full fat document\n    const { heads: _oldHeads } = state, stateSansHeads = __rest(state, [\"heads\"]);\n    stateSansHeads.patchCallback = opts.patchCallback;\n    return handle.applyPatches(doc, Object.assign(Object.assign({}, stateSansHeads), { handle }));\n}\n/** Explicity free the memory backing a document. Note that this is note\n * necessary in environments which support\n * [`FinalizationRegistry`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)\n */\nexport function free(doc) {\n    return _state(doc).handle.free();\n}\n/**\n * Create an automerge document from a POJO\n *\n * @param initialState - The initial state which will be copied into the document\n * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain\n * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used\n *\n * @example\n * ```\n * const doc = automerge.from({\n *     tasks: [\n *         {description: \"feed dogs\", done: false}\n *     ]\n * })\n * ```\n */\nexport function from(initialState, _opts) {\n    return _change(init(_opts), \"from\", {}, d => Object.assign(d, initialState))\n        .newDoc;\n}\n/**\n * Update the contents of an automerge document\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to update\n * @param options - Either a message, an {@link ChangeOptions}, or a {@link ChangeFn}\n * @param callback - A `ChangeFn` to be used if `options` was a `string`\n *\n * Note that if the second argument is a function it will be used as the `ChangeFn` regardless of what the third argument is.\n *\n * @example A simple change\n * ```\n * let doc1 = automerge.init()\n * doc1 = automerge.change(doc1, d => {\n *     d.key = \"value\"\n * })\n * assert.equal(doc1.key, \"value\")\n * ```\n *\n * @example A change with a message\n *\n * ```\n * doc1 = automerge.change(doc1, \"add another value\", d => {\n *     d.key2 = \"value2\"\n * })\n * ```\n *\n * @example A change with a message and a timestamp\n *\n * ```\n * doc1 = automerge.change(doc1, {message: \"add another value\", time: 1640995200}, d => {\n *     d.key2 = \"value2\"\n * })\n * ```\n *\n * @example responding to a patch callback\n * ```\n * let patchedPath\n * let patchCallback = patch => {\n *    patchedPath = patch.path\n * }\n * doc1 = automerge.change(doc1, {message: \"add another value\", time: 1640995200, patchCallback}, d => {\n *     d.key2 = \"value2\"\n * })\n * assert.equal(patchedPath, [\"key2\"])\n * ```\n */\nexport function change(doc, options, callback) {\n    if (typeof options === \"function\") {\n        return _change(doc, \"change\", {}, options).newDoc;\n    }\n    else if (typeof callback === \"function\") {\n        if (typeof options === \"string\") {\n            options = { message: options };\n        }\n        return _change(doc, \"change\", options, callback).newDoc;\n    }\n    else {\n        throw RangeError(\"Invalid args for change\");\n    }\n}\n/**\n * Make a change to the document as it was at a particular point in history\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to update\n * @param scope - The heads representing the point in history to make the change\n * @param options - Either a message or a {@link ChangeOptions} for the new change\n * @param callback - A `ChangeFn` to be used if `options` was a `string`\n *\n * @remarks\n * This function is similar to {@link change} but allows you to make changes to\n * the document as if it were at a particular point in time. To understand this\n * imagine a document created with the following history:\n *\n * ```ts\n * let doc = automerge.from({..})\n * doc = automerge.change(doc, () => {...})\n *\n * const heads = automerge.getHeads(doc)\n *\n * // fork the document make a change\n * let fork = automerge.fork(doc)\n * fork = automerge.change(fork, () => {...})\n * const headsOnFork = automerge.getHeads(fork)\n *\n * // make a change on the original doc\n * doc = automerge.change(doc, () => {...})\n * const headsOnOriginal = automerge.getHeads(doc)\n *\n * // now merge the changes back to the original document\n * doc = automerge.merge(doc, fork)\n *\n * // The heads of the document will now be (headsOnFork, headsOnOriginal)\n * ```\n *\n * {@link ChangeAt} produces an equivalent history, but without having to\n * create a fork of the document. In particular the `newHeads` field of the\n * returned {@link ChangeAtResult} will be the same as `headsOnFork`.\n *\n * Why would you want this? It's typically used in conjunction with {@link diff}\n * to reconcile state which is managed concurrently with the document. For\n * example, if you have a text editor component which the user is modifying\n * and you can't send the changes to the document synchronously you might follow\n * a workflow like this:\n *\n * * On initialization save the current heads of the document in the text editor state\n * * Every time the user makes a change record the change in the text editor state\n *\n * Now from time to time reconcile the editor state and the document\n * * Load the last saved heads from the text editor state, call them `oldHeads`\n * * Apply all the unreconciled changes to the document using `changeAt(doc, oldHeads, ...)`\n * * Get the diff from the resulting document to the current document using {@link diff}\n *   passing the {@link ChangeAtResult.newHeads} as the `before` argument and the\n *   heads of the entire document as the `after` argument.\n * * Apply the diff to the text editor state\n * * Save the current heads of the document in the text editor state\n */\nexport function changeAt(doc, scope, options, callback) {\n    if (typeof options === \"function\") {\n        return _change(doc, \"changeAt\", {}, options, scope);\n    }\n    else if (typeof callback === \"function\") {\n        if (typeof options === \"string\") {\n            options = { message: options };\n        }\n        return _change(doc, \"changeAt\", options, callback, scope);\n    }\n    else {\n        throw RangeError(\"Invalid args for changeAt\");\n    }\n}\nfunction progressDocument(doc, source, heads, callback) {\n    if (heads == null) {\n        return doc;\n    }\n    const state = _state(doc);\n    const nextState = Object.assign(Object.assign({}, state), { heads: undefined });\n    const { value: nextDoc, patches } = state.handle.applyAndReturnPatches(doc, nextState);\n    if (patches.length > 0) {\n        if (callback != null) {\n            callback(patches, { before: doc, after: nextDoc, source });\n        }\n        const newState = _state(nextDoc);\n        newState.mostRecentPatch = {\n            before: _state(doc).heads,\n            after: newState.handle.getHeads(),\n            patches,\n        };\n    }\n    state.heads = heads;\n    return nextDoc;\n}\nfunction _change(doc, source, options, callback, scope) {\n    if (typeof callback !== \"function\") {\n        throw new RangeError(\"invalid change function\");\n    }\n    const state = _state(doc);\n    if (doc === undefined || state === undefined) {\n        throw new RangeError(\"must be the document root\");\n    }\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    let heads = state.handle.getHeads();\n    if (scope && headsEqual(scope, heads)) {\n        scope = undefined;\n    }\n    if (scope) {\n        state.handle.isolate(scope);\n        heads = scope;\n    }\n    if (!(\"time\" in options)) {\n        options.time = Math.floor(Date.now() / 1000);\n    }\n    try {\n        state.heads = heads;\n        const root = rootProxy(state.handle, state.textV2);\n        callback(root);\n        if (state.handle.pendingOps() === 0) {\n            state.heads = undefined;\n            if (scope) {\n                state.handle.integrate();\n            }\n            return {\n                newDoc: doc,\n                newHeads: null,\n            };\n        }\n        else {\n            const newHead = state.handle.commit(options.message, options.time);\n            state.handle.integrate();\n            return {\n                newDoc: progressDocument(doc, source, heads, options.patchCallback || state.patchCallback),\n                newHeads: newHead != null ? [newHead] : null,\n            };\n        }\n    }\n    catch (e) {\n        state.heads = undefined;\n        state.handle.rollback();\n        throw e;\n    }\n}\n/**\n * Make a change to a document which does not modify the document\n *\n * @param doc - The doc to add the empty change to\n * @param options - Either a message or a {@link ChangeOptions} for the new change\n *\n * Why would you want to do this? One reason might be that you have merged\n * changes from some other peers and you want to generate a change which\n * depends on those merged changes so that you can sign the new change with all\n * of the merged changes as part of the new change.\n */\nexport function emptyChange(doc, options) {\n    if (options === undefined) {\n        options = {};\n    }\n    if (typeof options === \"string\") {\n        options = { message: options };\n    }\n    if (!(\"time\" in options)) {\n        options.time = Math.floor(Date.now() / 1000);\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.emptyChange(options.message, options.time);\n    return progressDocument(doc, \"emptyChange\", heads);\n}\n/**\n * Load an automerge document from a compressed document produce by {@link save}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressed document\n * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor\n *                ID is null a random actor ID will be created\n *\n * Note that `load` will throw an error if passed incomplete content (for\n * example if you are receiving content over the network and don't know if you\n * have the complete document yet). If you need to handle incomplete content use\n * {@link init} followed by {@link loadIncremental}.\n */\nexport function load(data, _opts) {\n    const opts = importOpts(_opts);\n    const actor = opts.actor;\n    const patchCallback = opts.patchCallback;\n    const text_v1 = !(opts.enableTextV2 || false);\n    const unchecked = opts.unchecked || false;\n    const allowMissingDeps = opts.allowMissingChanges || false;\n    const convertRawStringsToText = opts.convertRawStringsToText || false;\n    const handle = ApiHandler.load(data, {\n        text_v1,\n        actor,\n        unchecked,\n        allowMissingDeps,\n        convertRawStringsToText,\n    });\n    handle.enableFreeze(!!opts.freeze);\n    const textV2 = opts.enableTextV2 || false;\n    registerDatatypes(handle, textV2);\n    const doc = handle.materialize(\"/\", undefined, {\n        handle,\n        heads: undefined,\n        patchCallback,\n        textV2,\n    });\n    return doc;\n}\n/**\n * Load changes produced by {@link saveIncremental}, or partial changes\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressedchanges\n * @param opts  - an {@link ApplyOptions}\n *\n * This function is useful when staying up to date with a connected peer.\n * Perhaps the other end sent you a full compresed document which you loaded\n * with {@link load} and they're sending you the result of\n * {@link getLastLocalChange} every time they make a change.\n *\n * Note that this function will succesfully load the results of {@link save} as\n * well as {@link getLastLocalChange} or any other incremental change.\n */\nexport function loadIncremental(doc, data, opts) {\n    if (!opts) {\n        opts = {};\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(doc));\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.loadIncremental(data);\n    return progressDocument(doc, \"loadIncremental\", heads, opts.patchCallback || state.patchCallback);\n}\n/**\n * Create binary save data to be appended to a save file or fed into {@link loadIncremental}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n *\n * This function is useful for incrementally saving state.  The data can be appended to a\n * automerge save file, or passed to a document replicating its state.\n *\n */\nexport function saveIncremental(doc) {\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(doc));\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    return state.handle.saveIncremental();\n}\n/**\n * Export the contents of a document to a compressed format\n *\n * @param doc - The doc to save\n *\n * The returned bytes can be passed to {@link load} or {@link loadIncremental}\n */\nexport function save(doc) {\n    return _state(doc).handle.save();\n}\n/**\n * Merge `remote` into `local`\n * @typeParam T - The type of values contained in each document\n * @param local - The document to merge changes into\n * @param remote - The document to merge changes from\n *\n * @returns - The merged document\n *\n * Often when you are merging documents you will also need to clone them. Both\n * arguments to `merge` are frozen after the call so you can no longer call\n * mutating methods (such as {@link change}) on them. The symtom of this will be\n * an error which says \"Attempting to change an out of date document\". To\n * overcome this call {@link clone} on the argument before passing it to {@link\n * merge}.\n */\nexport function merge(local, remote) {\n    const localState = _state(local);\n    if (localState.heads) {\n        throw new RangeError(\"Attempting to change an out of date document - set at: \" + _trace(local));\n    }\n    const heads = localState.handle.getHeads();\n    const remoteState = _state(remote);\n    const changes = localState.handle.getChangesAdded(remoteState.handle);\n    localState.handle.applyChanges(changes);\n    return progressDocument(local, \"merge\", heads, localState.patchCallback);\n}\n/**\n * Get the actor ID associated with the document\n */\nexport function getActorId(doc) {\n    const state = _state(doc);\n    return state.handle.getActorId();\n}\n/**\n * Get the conflicts associated with a property\n *\n * The values of properties in a map in automerge can be conflicted if there\n * are concurrent \"put\" operations to the same key. Automerge chooses one value\n * arbitrarily (but deterministically, any two nodes who have the same set of\n * changes will choose the same value) from the set of conflicting values to\n * present as the value of the key.\n *\n * Sometimes you may want to examine these conflicts, in this case you can use\n * {@link getConflicts} to get the conflicts for the key.\n *\n * @example\n * ```\n * import * as automerge from \"@automerge/automerge\"\n *\n * type Profile = {\n *     pets: Array<{name: string, type: string}>\n * }\n *\n * let doc1 = automerge.init<Profile>(\"aaaa\")\n * doc1 = automerge.change(doc1, d => {\n *     d.pets = [{name: \"Lassie\", type: \"dog\"}]\n * })\n * let doc2 = automerge.init<Profile>(\"bbbb\")\n * doc2 = automerge.merge(doc2, automerge.clone(doc1))\n *\n * doc2 = automerge.change(doc2, d => {\n *     d.pets[0].name = \"Beethoven\"\n * })\n *\n * doc1 = automerge.change(doc1, d => {\n *     d.pets[0].name = \"Babe\"\n * })\n *\n * const doc3 = automerge.merge(doc1, doc2)\n *\n * // Note that here we pass `doc3.pets`, not `doc3`\n * let conflicts = automerge.getConflicts(doc3.pets[0], \"name\")\n *\n * // The two conflicting values are the keys of the conflicts object\n * assert.deepEqual(Object.values(conflicts), [\"Babe\", Beethoven\"])\n * ```\n */\nexport function getConflicts(doc, prop) {\n    const state = _state(doc, false);\n    if (state.textV2) {\n        throw new Error(\"use unstable.getConflicts for an unstable document\");\n    }\n    const objectId = _obj(doc);\n    if (objectId != null) {\n        return stableConflictAt(state.handle, objectId, prop);\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Get the binary representation of the last change which was made to this doc\n *\n * This is most useful when staying in sync with other peers, every time you\n * make a change locally via {@link change} you immediately call {@link\n * getLastLocalChange} and send the result over the network to other peers.\n */\nexport function getLastLocalChange(doc) {\n    const state = _state(doc);\n    return state.handle.getLastLocalChange() || undefined;\n}\n/**\n * Return the object ID of an arbitrary javascript value\n *\n * This is useful to determine if something is actually an automerge document,\n * if `doc` is not an automerge document this will return null.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getObjectId(doc, prop) {\n    if (prop) {\n        const state = _state(doc, false);\n        const objectId = _obj(doc);\n        if (!state || !objectId) {\n            return null;\n        }\n        return state.handle.get(objectId, prop);\n    }\n    else {\n        return _obj(doc);\n    }\n}\n/**\n * Get the changes which are in `newState` but not in `oldState`. The returned\n * changes can be loaded in `oldState` via {@link applyChanges}.\n *\n * Note that this will crash if there are changes in `oldState` which are not in `newState`.\n */\nexport function getChanges(oldState, newState) {\n    const n = _state(newState);\n    return n.handle.getChanges(getHeads(oldState));\n}\n/**\n * Get all the changes in a document\n *\n * This is different to {@link save} because the output is an array of changes\n * which can be individually applied via {@link applyChanges}`\n *\n */\nexport function getAllChanges(doc) {\n    const state = _state(doc);\n    return state.handle.getChanges([]);\n}\n/**\n * Apply changes received from another document\n *\n * `doc` will be updated to reflect the `changes`. If there are changes which\n * we do not have dependencies for yet those will be stored in the document and\n * applied when the depended on changes arrive.\n *\n * You can use the {@link ApplyOptions} to pass a patchcallback which will be\n * informed of any changes which occur as a result of applying the changes\n *\n */\nexport function applyChanges(doc, changes, opts) {\n    const state = _state(doc);\n    if (!opts) {\n        opts = {};\n    }\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.applyChanges(changes);\n    state.heads = heads;\n    return [\n        progressDocument(doc, \"applyChanges\", heads, opts.patchCallback || state.patchCallback),\n    ];\n}\n/** @hidden */\nexport function getHistory(doc) {\n    const textV2 = _state(doc).textV2;\n    const history = getAllChanges(doc);\n    return history.map((change, index) => ({\n        get change() {\n            return decodeChange(change);\n        },\n        get snapshot() {\n            const [state] = applyChanges(init({ enableTextV2: textV2 }), history.slice(0, index + 1));\n            return state;\n        },\n    }));\n}\n/**\n * Create a set of patches representing the change from one set of heads to another\n *\n * If either of the heads are missing from the document the returned set of patches will be empty\n */\nexport function diff(doc, before, after) {\n    checkHeads(before, \"before\");\n    checkHeads(after, \"after\");\n    const state = _state(doc);\n    if (state.mostRecentPatch &&\n        equals(state.mostRecentPatch.before, before) &&\n        equals(state.mostRecentPatch.after, after)) {\n        return state.mostRecentPatch.patches;\n    }\n    return state.handle.diff(before, after);\n}\nfunction headsEqual(heads1, heads2) {\n    if (heads1.length !== heads2.length) {\n        return false;\n    }\n    for (let i = 0; i < heads1.length; i++) {\n        if (heads1[i] !== heads2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction checkHeads(heads, fieldname) {\n    if (!Array.isArray(heads)) {\n        throw new Error(`${fieldname} must be an array`);\n    }\n}\n/** @hidden */\n// FIXME : no tests\n// FIXME can we just use deep equals now?\nexport function equals(val1, val2) {\n    if (!isObject(val1) || !isObject(val2))\n        return val1 === val2;\n    const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort();\n    if (keys1.length !== keys2.length)\n        return false;\n    for (let i = 0; i < keys1.length; i++) {\n        if (keys1[i] !== keys2[i])\n            return false;\n        if (!equals(val1[keys1[i]], val2[keys2[i]]))\n            return false;\n    }\n    return true;\n}\n/**\n * encode a {@link SyncState} into binary to send over the network\n *\n * @group sync\n * */\nexport function encodeSyncState(state) {\n    const sync = ApiHandler.importSyncState(state);\n    const result = ApiHandler.encodeSyncState(sync);\n    sync.free();\n    return result;\n}\n/**\n * Decode some binary data into a {@link SyncState}\n *\n * @group sync\n */\nexport function decodeSyncState(state) {\n    const sync = ApiHandler.decodeSyncState(state);\n    const result = ApiHandler.exportSyncState(sync);\n    sync.free();\n    return result;\n}\n/**\n * Generate a sync message to send to the peer represented by `inState`\n * @param doc - The doc to generate messages about\n * @param inState - The {@link SyncState} representing the peer we are talking to\n *\n * @group sync\n *\n * @returns An array of `[newSyncState, syncMessage | null]` where\n * `newSyncState` should replace `inState` and `syncMessage` should be sent to\n * the peer if it is not null. If `syncMessage` is null then we are up to date.\n */\nexport function generateSyncMessage(doc, inState) {\n    const state = _state(doc);\n    const syncState = ApiHandler.importSyncState(inState);\n    const message = state.handle.generateSyncMessage(syncState);\n    const outState = ApiHandler.exportSyncState(syncState);\n    return [outState, message];\n}\n/**\n * Update a document and our sync state on receiving a sync message\n *\n * @group sync\n *\n * @param doc     - The doc the sync message is about\n * @param inState - The {@link SyncState} for the peer we are communicating with\n * @param message - The message which was received\n * @param opts    - Any {@link ApplyOption}s, used for passing a\n *                  {@link PatchCallback} which will be informed of any changes\n *                  in `doc` which occur because of the received sync message.\n *\n * @returns An array of `[newDoc, newSyncState, syncMessage | null]` where\n * `newDoc` is the updated state of `doc`, `newSyncState` should replace\n * `inState` and `syncMessage` should be sent to the peer if it is not null. If\n * `syncMessage` is null then we are up to date.\n */\nexport function receiveSyncMessage(doc, inState, message, opts) {\n    const syncState = ApiHandler.importSyncState(inState);\n    if (!opts) {\n        opts = {};\n    }\n    const state = _state(doc);\n    if (state.heads) {\n        throw new RangeError(\"Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.\");\n    }\n    if (_is_proxy(doc)) {\n        throw new RangeError(\"Calls to Automerge.change cannot be nested\");\n    }\n    const heads = state.handle.getHeads();\n    state.handle.receiveSyncMessage(syncState, message);\n    const outSyncState = ApiHandler.exportSyncState(syncState);\n    return [\n        progressDocument(doc, \"receiveSyncMessage\", heads, opts.patchCallback || state.patchCallback),\n        outSyncState,\n        null,\n    ];\n}\n/**\n * Check whether the replica represented by `remoteState` has all our changes\n *\n * @param doc - The doc to check whether the remote has changes for\n * @param remoteState - The {@link SyncState} representing the peer we are talking to\n *\n * @group sync\n *\n * @returns true if the remote has all of our changes\n */\nexport function hasOurChanges(doc, remoteState) {\n    const state = _state(doc);\n    const syncState = ApiHandler.importSyncState(remoteState);\n    return state.handle.hasOurChanges(syncState);\n}\n/**\n * Create a new, blank {@link SyncState}\n *\n * When communicating with a peer for the first time use this to generate a new\n * {@link SyncState} for them\n *\n * @group sync\n */\nexport function initSyncState() {\n    return ApiHandler.exportSyncState(ApiHandler.initSyncState());\n}\n/** @hidden */\nexport function encodeChange(change) {\n    return ApiHandler.encodeChange(change);\n}\n/** @hidden */\nexport function decodeChange(data) {\n    return ApiHandler.decodeChange(data);\n}\n/** @hidden */\nexport function encodeSyncMessage(message) {\n    return ApiHandler.encodeSyncMessage(message);\n}\n/** @hidden */\nexport function decodeSyncMessage(message) {\n    return ApiHandler.decodeSyncMessage(message);\n}\n/**\n * Get any changes in `doc` which are not dependencies of `heads`\n */\nexport function getMissingDeps(doc, heads) {\n    const state = _state(doc);\n    return state.handle.getMissingDeps(heads);\n}\n/**\n * Get the hashes of the heads of this document\n */\nexport function getHeads(doc) {\n    const state = _state(doc);\n    return state.heads || state.handle.getHeads();\n}\n/** @hidden */\nexport function dump(doc) {\n    const state = _state(doc);\n    state.handle.dump();\n}\n/** @hidden */\nexport function toJS(doc) {\n    const state = _state(doc);\n    const enabled = state.handle.enableFreeze(false);\n    const result = state.handle.materialize();\n    state.handle.enableFreeze(enabled);\n    return result;\n}\nexport function isAutomerge(doc) {\n    if (typeof doc == \"object\" && doc !== null) {\n        return getObjectId(doc) === \"_root\" && !!Reflect.get(doc, STATE);\n    }\n    else {\n        return false;\n    }\n}\nfunction isObject(obj) {\n    return typeof obj === \"object\" && obj !== null;\n}\nexport function saveSince(doc, heads) {\n    const state = _state(doc);\n    const result = state.handle.saveSince(heads);\n    return result;\n}\n/**\n * Returns true if the document has all of the given heads somewhere in its history\n */\nexport function hasHeads(doc, heads) {\n    const state = _state(doc);\n    for (const hash of heads) {\n        if (!state.handle.getChangeByHash(hash)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction registerDatatypes(handle, textV2) {\n    handle.registerDatatype(\"counter\", (n) => new Counter(n), n => {\n        if (n instanceof Counter) {\n            return n.value;\n        }\n    });\n    if (textV2) {\n        handle.registerDatatype(\"str\", (n) => {\n            return new RawString(n);\n        }, s => {\n            if (s instanceof RawString) {\n                return s.val;\n            }\n        });\n    }\n    else {\n        handle.registerDatatype(\"text\", (n) => new Text(n), t => {\n            if (t instanceof Text) {\n                return t.join(\"\");\n            }\n        });\n    }\n}\n/**\n * @hidden\n */\nexport function topoHistoryTraversal(doc) {\n    const state = _state(doc);\n    return state.handle.topoHistoryTraversal();\n}\n/**\n * Decode a change hash into the details of this change\n *\n * This should be considered a semi-stable API. We try not to change the\n * encoding in backwards incompatible ways but we won't bump a major version if\n * we do have to change it\n */\nexport function inspectChange(doc, changeHash) {\n    const state = _state(doc);\n    return state.handle.getDecodedChangeByHash(changeHash);\n}\n/**\n * Return some internal statistics about the document\n */\nexport function stats(doc) {\n    const state = _state(doc);\n    return state.handle.stats();\n}\n", "/**\n * # The next API\n *\n * This module contains new features we are working on which are backwards\n * incompatible with the current API of Automerge. This module will become the\n * API of the next major version of Automerge\n *\n * ## Differences from stable\n *\n * In the stable API text objects are represented using the {@link Text} class.\n * This means you must decide up front whether your string data might need\n * concurrent merges in the future and if you change your mind you have to\n * figure out how to migrate your data. In the unstable API the `Text` class is\n * gone and all `string`s are represented using the text CRDT, allowing for\n * concurrent changes. Modifying a string is done using the {@link splice}\n * function. You can still access the old behaviour of strings which do not\n * support merging behaviour via the {@link RawString} class.\n *\n * This leads to the following differences from `stable`:\n *\n * * There is no `unstable.Text` class, all strings are text objects\n * * Reading strings in an `unstable` document is the same as reading any other\n *   javascript string\n * * To modify strings in an `unstable` document use {@link splice}\n * * The {@link AutomergeValue} type does not include the {@link Text}\n *   class but the  {@link RawString} class is included in the {@link ScalarValue}\n *   type\n *\n * ## CHANGELOG\n * * Rename this module to `next` to reflect our increased confidence in it\n *   and stability commitment to it\n * * Introduce this module to expose the new API which has no `Text` class\n *\n *\n * @module\n */\nexport { Counter, Int, Uint, Float64, } from \"./next_types.js\";\nimport { unstableConflictAt } from \"./conflicts.js\";\nexport { view, free, getHeads, change, changeAt, emptyChange, loadIncremental, saveIncremental, save, merge, getActorId, getLastLocalChange, getChanges, getAllChanges, applyChanges, getHistory, equals, encodeSyncState, decodeSyncState, generateSyncMessage, receiveSyncMessage, hasOurChanges, initSyncState, encodeChange, decodeChange, encodeSyncMessage, decodeSyncMessage, getMissingDeps, dump, toJS, isAutomerge, getObjectId, diff, insertAt, deleteAt, saveSince, initializeWasm, initializeBase64Wasm, wasmInitialized, isWasmInitialized, hasHeads, topoHistoryTraversal, inspectChange, stats, } from \"./stable.js\";\nimport * as stable from \"./stable.js\";\nexport { RawString } from \"./raw_string.js\";\n/** @hidden */\nexport const getBackend = stable.getBackend;\nimport { _is_proxy, _state, _obj, _clear_cache } from \"./internal_state.js\";\n/**\n * Create a new automerge document\n *\n * @typeParam T - The type of value contained in the document. This will be the\n *     type that is passed to the change closure in {@link change}\n * @param _opts - Either an actorId or an {@link InitOptions} (which may\n *     contain an actorId). If this is null the document will be initialised with a\n *     random actor ID\n */\nexport function init(_opts) {\n    const opts = importOpts(_opts);\n    opts.enableTextV2 = true;\n    return stable.init(opts);\n}\n/**\n * Make a full writable copy of an automerge document\n *\n * @remarks\n * Unlike {@link view} this function makes a full copy of the memory backing\n * the document and can thus be passed to {@link change}. It also generates a\n * new actor ID so that changes made in the new document do not create duplicate\n * sequence numbers with respect to the old document. If you need control over\n * the actor ID which is generated you can pass the actor ID as the second\n * argument\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to clone\n * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}\n */\nexport function clone(doc, _opts) {\n    const opts = importOpts(_opts);\n    opts.enableTextV2 = true;\n    return stable.clone(doc, opts);\n}\n/**\n * Create an automerge document from a POJO\n *\n * @param initialState - The initial state which will be copied into the document\n * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain\n * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used\n *\n * @example\n * ```\n * const doc = automerge.from({\n *     tasks: [\n *         {description: \"feed dogs\", done: false}\n *     ]\n * })\n * ```\n */\nexport function from(initialState, _opts) {\n    const opts = importOpts(_opts);\n    opts.enableTextV2 = true;\n    return stable.from(initialState, opts);\n}\n/**\n * Load an automerge document from a compressed document produce by {@link save}\n *\n * @typeParam T - The type of the value which is contained in the document.\n *                Note that no validation is done to make sure this type is in\n *                fact the type of the contained value so be a bit careful\n * @param data  - The compressed document\n * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor\n *                ID is null a random actor ID will be created\n *\n * Note that `load` will throw an error if passed incomplete content (for\n * example if you are receiving content over the network and don't know if you\n * have the complete document yet). If you need to handle incomplete content use\n * {@link init} followed by {@link loadIncremental}.\n */\nexport function load(data, _opts) {\n    const opts = importOpts(_opts);\n    opts.enableTextV2 = true;\n    if (opts.patchCallback) {\n        return stable.loadIncremental(stable.init(opts), data);\n    }\n    else {\n        return stable.load(data, opts);\n    }\n}\nfunction importOpts(_actor) {\n    if (typeof _actor === \"object\") {\n        return _actor;\n    }\n    else {\n        return { actor: _actor };\n    }\n}\nfunction cursorToIndex(state, value, index) {\n    if (typeof index == \"string\") {\n        if (/^[0-9]+@[0-9a-zA-z]+$/.test(index)) {\n            return state.handle.getCursorPosition(value, index);\n        }\n        else {\n            throw new RangeError(\"index must be a number or cursor\");\n        }\n    }\n    else {\n        return index;\n    }\n}\n/**\n * Modify a string\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to modify\n * @param path - The path to the string to modify\n * @param index - The position (as a {@link Cursor} or index) to edit.\n *   If a cursor is used then the edit happens such that the cursor will\n *   now point to the end of the newText, so you can continue to reuse\n *   the same cursor for multiple calls to splice.\n * @param del - The number of code units to delete, a positive number\n *   deletes N characters after the cursor, a negative number deletes\n *   N characters before the cursor.\n * @param newText - The string to insert (if any).\n */\nexport function splice(doc, path, index, del, newText) {\n    const objPath = absoluteObjPath(doc, path, \"splice\");\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        return state.handle.splice(objPath, index, del, newText);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot splice: ${e}`);\n    }\n}\n/**\n * Update the value of a string\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document to modify\n * @param path - The path to the string to modify\n * @param newText - The new text to update the value to\n *\n * @remarks\n * This will calculate a diff between the current value and the new value and\n * then convert that diff into calls to {@link splice}. This will produce results\n * which don't merge as well as directly capturing the user input actions, but\n * sometimes it's not possible to capture user input and this is the best you\n * can do.\n *\n * This is an experimental API and may change in the future.\n *\n * @beta\n */\nexport function updateText(doc, path, newText) {\n    const objPath = absoluteObjPath(doc, path, \"updateText\");\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    try {\n        return state.handle.updateText(objPath, newText);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot updateText: ${e}`);\n    }\n}\n/**\n * Return the text + block markers at a given path\n *\n * @remarks\n * Rich text in automerge is represented as a sequence of characters with block\n * markers appearing inline with the text, and inline formatting spans overlaid\n * on the whole sequence. Block markers are normal automerge maps, but they are\n * only visible via either the {@link block} function or the {@link spans}\n * function. This function returns the current state of the spans\n */\nexport function spans(doc, path) {\n    const state = _state(doc, false);\n    const objPath = absoluteObjPath(doc, path, \"spans\");\n    try {\n        return state.handle.spans(objPath, state.heads);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot splice: ${e}`);\n    }\n}\n/**\n * Get the block marker at the given index\n */\nexport function block(doc, path, index) {\n    const objPath = absoluteObjPath(doc, path, \"splitBlock\");\n    const state = _state(doc, false);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        return state.handle.getBlock(objPath, index);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot get block: ${e}`);\n    }\n}\n/**\n * Insert a new block marker at the given index\n */\nexport function splitBlock(doc, path, index, block) {\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const objPath = absoluteObjPath(doc, path, \"splitBlock\");\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        state.handle.splitBlock(objPath, index, block);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot splice: ${e}`);\n    }\n}\n/**\n * Delete the block marker at the given index\n */\nexport function joinBlock(doc, path, index) {\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const objPath = absoluteObjPath(doc, path, \"joinBlock\");\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        state.handle.joinBlock(objPath, index);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot joinBlock: ${e}`);\n    }\n}\n/**\n * Update the block marker at the given index\n */\nexport function updateBlock(doc, path, index, block) {\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const objPath = absoluteObjPath(doc, path, \"updateBlock\");\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    index = cursorToIndex(state, objPath, index);\n    try {\n        state.handle.updateBlock(objPath, index, block);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot updateBlock: ${e}`);\n    }\n}\n/**\n * Update the spans at the given path\n *\n * @remarks\n * Like {@link updateText} this will diff `newSpans` against the current state\n * of the text at `path` and perform a reasonably minimal number of operations\n * required to update the spans to the new state.\n */\nexport function updateSpans(doc, path, newSpans) {\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const objPath = absoluteObjPath(doc, path, \"updateSpans\");\n    const state = _state(doc, false);\n    _clear_cache(doc);\n    try {\n        state.handle.updateSpans(objPath, newSpans);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot updateBlock: ${e}`);\n    }\n}\n/**\n * Returns a cursor for the given position in a string.\n *\n * @remarks\n * A cursor represents a relative position, \"before character X\",\n * rather than an absolute position. As the document is edited, the\n * cursor remains stable relative to its context, just as you'd expect\n * from a cursor in a concurrent text editor.\n *\n * The string representation is shareable, and so you can use this both\n * to edit the document yourself (using {@link splice}) or to share multiple\n * collaborator's current cursor positions over the network.\n *\n * @typeParam T - The type of the value contained in the document\n * @param doc - The document\n * @param path - The path to the string\n * @param index - The current index of the position of the cursor\n */\nexport function getCursor(doc, path, index) {\n    const objPath = absoluteObjPath(doc, path, \"getCursor\");\n    const state = _state(doc, false);\n    try {\n        return state.handle.getCursor(objPath, index);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot getCursor: ${e}`);\n    }\n}\n/**\n * Returns the current index of the cursor.\n *\n * @typeParam T - The type of the value contained in the document\n *\n * @param doc - The document\n * @param path - The path to the string\n * @param index - The cursor\n */\nexport function getCursorPosition(doc, path, cursor) {\n    const objPath = absoluteObjPath(doc, path, \"getCursorPosition\");\n    const state = _state(doc, false);\n    try {\n        return state.handle.getCursorPosition(objPath, cursor);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot getCursorPosition: ${e}`);\n    }\n}\nexport function mark(doc, path, range, name, value) {\n    const objPath = absoluteObjPath(doc, path, \"mark\");\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = _state(doc, false);\n    try {\n        return state.handle.mark(objPath, range, name, value);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot mark: ${e}`);\n    }\n}\nexport function unmark(doc, path, range, name) {\n    const objPath = absoluteObjPath(doc, path, \"unmark\");\n    if (!_is_proxy(doc)) {\n        throw new RangeError(\"object cannot be modified outside of a change block\");\n    }\n    const state = _state(doc, false);\n    try {\n        return state.handle.unmark(objPath, range, name);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot unmark: ${e}`);\n    }\n}\nexport function marks(doc, path) {\n    const objPath = absoluteObjPath(doc, path, \"marks\");\n    const state = _state(doc, false);\n    try {\n        return state.handle.marks(objPath);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot call marks(): ${e}`);\n    }\n}\nexport function marksAt(doc, path, index) {\n    const objPath = absoluteObjPath(doc, path, \"marksAt\");\n    const state = _state(doc, false);\n    try {\n        return state.handle.marksAt(objPath, index);\n    }\n    catch (e) {\n        throw new RangeError(`Cannot call marksAt(): ${e}`);\n    }\n}\n/**\n * Get the conflicts associated with a property\n *\n * The values of properties in a map in automerge can be conflicted if there\n * are concurrent \"put\" operations to the same key. Automerge chooses one value\n * arbitrarily (but deterministically, any two nodes who have the same set of\n * changes will choose the same value) from the set of conflicting values to\n * present as the value of the key.\n *\n * Sometimes you may want to examine these conflicts, in this case you can use\n * {@link getConflicts} to get the conflicts for the key.\n *\n * @example\n * ```\n * import * as automerge from \"@automerge/automerge\"\n *\n * type Profile = {\n *     pets: Array<{name: string, type: string}>\n * }\n *\n * let doc1 = automerge.init<Profile>(\"aaaa\")\n * doc1 = automerge.change(doc1, d => {\n *     d.pets = [{name: \"Lassie\", type: \"dog\"}]\n * })\n * let doc2 = automerge.init<Profile>(\"bbbb\")\n * doc2 = automerge.merge(doc2, automerge.clone(doc1))\n *\n * doc2 = automerge.change(doc2, d => {\n *     d.pets[0].name = \"Beethoven\"\n * })\n *\n * doc1 = automerge.change(doc1, d => {\n *     d.pets[0].name = \"Babe\"\n * })\n *\n * const doc3 = automerge.merge(doc1, doc2)\n *\n * // Note that here we pass `doc3.pets`, not `doc3`\n * let conflicts = automerge.getConflicts(doc3.pets[0], \"name\")\n *\n * // The two conflicting values are the keys of the conflicts object\n * assert.deepEqual(Object.values(conflicts), [\"Babe\", \"Beethoven\"])\n * ```\n */\nexport function getConflicts(doc, prop) {\n    const state = _state(doc, false);\n    if (!state.textV2) {\n        throw new Error(\"use getConflicts for a stable document\");\n    }\n    const objectId = _obj(doc);\n    if (objectId != null) {\n        return unstableConflictAt(state.handle, objectId, prop);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction absoluteObjPath(doc, path, functionName) {\n    path = path.slice();\n    const objectId = _obj(doc);\n    if (!objectId) {\n        throw new RangeError(`invalid object for ${functionName}`);\n    }\n    path.unshift(objectId);\n    return path.join(\"/\");\n}\n"],
  "mappings": "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",
  "names": ["f", "uuid", "uuid", "uuid", "URL", "view", "ptr", "change", "f", "module", "change", "key", "i", "index", "f", "spans", "context", "load", "change", "decodeChange", "encodeSyncState", "decodeSyncState", "initSyncState", "encodeChange", "encodeSyncMessage", "decodeSyncMessage", "clone", "decodeChange", "decodeSyncMessage", "decodeSyncState", "encodeChange", "encodeSyncMessage", "encodeSyncState", "from", "getBackend", "getConflicts", "init", "initSyncState", "load", "getBackend", "init", "importOpts", "clone", "from", "load", "block", "getConflicts"]
}
